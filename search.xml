<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【文献阅读】Delay-Aware and Energy-Efficient Computation Offloading in Mobile-Edge Computing Using Deep Reinforcement Learning：基于深度强化学习的移动边缘计算的延迟感知和节能计算卸载</title>
      <link href="/2023/09/14/wen-xian-yue-du-delay-aware-and-energy-efficient-computation-offloading-in-mobile-edge-computing-using-deep-reinforcement-learning-ji-yu-shen-du-qiang-hua-xue-xi-de-yi-dong-bian-yuan-ji-suan-de-yan-chi-gan-zhi-he-jie-neng-ji-suan-xie-zai/"/>
      <url>/2023/09/14/wen-xian-yue-du-delay-aware-and-energy-efficient-computation-offloading-in-mobile-edge-computing-using-deep-reinforcement-learning-ji-yu-shen-du-qiang-hua-xue-xi-de-yi-dong-bian-yuan-ji-suan-de-yan-chi-gan-zhi-he-jie-neng-ji-suan-xie-zai/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：Laha Ale <em>et al.</em></p><p>发表时间：2021年</p><p>来源：IEEE TRANSACTIONS ON COGNITIVE COMMUNICATIONS AND NETWORKING（IF:8.6、Q1）</p><p>关键字：移动边缘计算，深度强化学习，计算卸载，<strong>延迟</strong>，<strong>能量效率</strong></p></blockquote><h2 id="1-这篇论文试图在解决什么问题"><a href="#1-这篇论文试图在解决什么问题" class="headerlink" title="1.这篇论文试图在解决什么问题"></a>1.这篇论文试图在解决什么问题</h2><p>提出一个<strong>联合优化</strong>问题，使用了DQN+<em><strong>ϵ−greedy</strong></em>+<strong>clip奖励</strong>的trick方法，用于在<strong>多个MEC</strong>和<strong>多个用户</strong>的动态MEC网络中实现<strong>延迟感知</strong>和<strong>高效节能</strong>的卸载</p><h2 id="2-这是否是一个新的问题"><a href="#2-这是否是一个新的问题" class="headerlink" title="2.这是否是一个新的问题"></a>2.这是否是一个新的问题</h2><p>否</p><h2 id="3-这篇文章要验证一个什么科学假设"><a href="#3-这篇文章要验证一个什么科学假设" class="headerlink" title="3.这篇文章要验证一个什么科学假设"></a>3.这篇文章要验证一个什么科学假设</h2><p>使用E2W_DRL（端到端的深度强化学习方法，具体是DQN）解决多用户多MEC的动态MEC网络的计算卸载</p><h2 id="4-论文中提到的解决方案的关键是什么"><a href="#4-论文中提到的解决方案的关键是什么" class="headerlink" title="4.论文中提到的解决方案的关键是什么"></a>4.论文中提到的解决方案的关键是什么</h2><p>延迟感知的计算卸载：即MEC网络环境中的任务队列以一定的时间间隙t接收用户的任务 $Ω_{t}$，智能体以时间步长[0,τ]的范围内按照队列顺序执行一次任务，$τ&lt;&lt; t$</p><p>clip奖励的trick：对于一些训练样本的范围大，方差大的特征，可能会影响模型的收敛，所以每次对奖励进行clip可以防止梯度消失和梯度爆炸，有助于提高模型训练的稳定性 </p><p><em><strong>ϵ−greedy</strong></em>：平衡交互和探索，让模型更好地从环境中学习</p><p>DNN（深度神经网络）：DQN-Proposed使用DNN作为非线性函数近似Q函数，用于缩小探索范围</p><h2 id="5-论文中的实验是如何设计的"><a href="#5-论文中的实验是如何设计的" class="headerlink" title="5.论文中的实验是如何设计的"></a>5.论文中的实验是如何设计的</h2><p>系统模型：</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20230914222330.png" style="zoom: 80%;"><p>主要体现在设置优化目标和奖励函数（<strong>联合优化</strong>）设计上</p><p>优化目标：最大化截止时间前任务完成数量和最小化能源（计算+传输）消耗</p><p>优化问题表述：</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20230912000530.png"></p><p>暴露的问题：</p><ol><li>不能保证所有任务满足约束条件1，<strong>Agent需要考虑可行域内无解的情况</strong></li><li><strong>平衡</strong>能量消耗成本和传输消耗成本的<strong>灵活度</strong>不够</li><li>能量消耗成本$E_{τ}^C$公式包含了平方项，其会随着变量增加和问题规模的增加而呈指数型增长</li></ol><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20230912001811.png"></p><h2 id="6-用于定量评估的数据集、指标，算法对比，代码是否开源"><a href="#6-用于定量评估的数据集、指标，算法对比，代码是否开源" class="headerlink" title="6.用于定量评估的数据集、指标，算法对比，代码是否开源"></a>6.用于定量评估的数据集、指标，算法对比，代码是否开源</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>目标网络将已经交互样本存入经验缓冲池，学习网络则批量随机抽取样本学习</p><h3 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h3><p>奖励、任务完成数量、平均能量消耗、能量与任务的之比、<em><strong>ϵ−greedy</strong></em>技巧中平衡探索和交互的 <strong>ϵ</strong></p><h3 id="对比的算法"><a href="#对比的算法" class="headerlink" title="对比的算法"></a>对比的算法</h3><p>分别使用了DRL（CVX）方法、贪婪两种方法对本文提出的E2E_DRL（DQN）方法进行对比</p><p>此外，还使用了10个用户和1000个用户对上述三种方法进行对比</p><p><em>注：CVX表示凸优化工具箱CVX，那么它是一个基于Matlab的凸优化工具包，能够解决线性规划，二次规划等优化问题</em></p><h3 id="代码是否开源"><a href="#代码是否开源" class="headerlink" title="代码是否开源"></a>代码是否开源</h3><p>否</p><h2 id="７-论文中的实验及结果有没有很好地支持需要验证的科学假设"><a href="#７-论文中的实验及结果有没有很好地支持需要验证的科学假设" class="headerlink" title="７.论文中的实验及结果有没有很好地支持需要验证的科学假设"></a>７.论文中的实验及结果有没有很好地支持需要验证的科学假设</h2><p>同等条件下，奖励更高、任务完成数更多、但是能源消耗最高；因为DQN探索和交互的时候使用<em><strong>ϵ−greedy</strong></em>消耗了更多的能量。</p><p>同等条件下，使用DRL-CVX能源消耗较低，但是DRL-CVX不会增加完成任务数量；因为DRL-CVX只控制部分的决策变量（相比于DNN，它更简单），它会随着参数数量和搜索范围的增加，计算成本呈指数增长（但是论文未给出验证）</p><h2 id="８-这篇论文的贡献"><a href="#８-这篇论文的贡献" class="headerlink" title="８.这篇论文的贡献"></a>８.这篇论文的贡献</h2><ol><li>研究了动态MEC网络中的计算卸载问题</li><li>提出了一种端到端DRL方法来联合优化边缘服务器的选择和计算能力分配，以最大化按时完成的任务数和同时最小化能量消耗为目标</li><li>该模型可以在不依赖其他优化函数的情况下完成所有决策，从而达到联合优化的目的</li><li>采用经验缓冲区回放和剪辑技术来促进DRL模型的训练过程，可以防止模型出现振荡和发散</li></ol><h2 id="９-未来的工作如何进展"><a href="#９-未来的工作如何进展" class="headerlink" title="９.未来的工作如何进展"></a>９.未来的工作如何进展</h2><ol><li>研究动态卸载中的任务划分，任务可以任意划分，然后卸载到边缘服务器上</li></ol>]]></content>
      
      
      <categories>
          
          <category> 移动边缘计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动边缘计算 </tag>
            
            <tag> 文献阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="/2022/08/07/docker-xue-xi-bi-ji/"/>
      <url>/2022/08/07/docker-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker"><a href="#一、Docker" class="headerlink" title="一、Docker"></a>一、Docker</h1><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker命令大全</a></p><h2 id="（一）常用命令"><a href="#（一）常用命令" class="headerlink" title="（一）常用命令"></a>（一）常用命令</h2><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><pre><code class="hljs linux">docker run -itd --privileged=true&nbsp; --name &lt;你的容器名字&gt; -p 6000（你的电脑端口）:6000（对应映射容器的端口）（可以进行多个端口映射） centos（用哪种镜像创建）:7（镜像的Tag） /usr/sbin/init（表示使用bash进行命令操作）</code></pre><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</p><pre><code class="hljs linux">docker run -itd --privileged=true --name my_centos7 -p 50001:22 -p 50002:3306 centos:7 /usr/sbin/init</code></pre><h3 id="关于docker镜像内安装命令"><a href="#关于docker镜像内安装命令" class="headerlink" title="关于docker镜像内安装命令"></a>关于docker镜像内安装命令</h3><pre><code class="hljs linux">apt-get update &amp;&amp; apt-get install lrzszyum -y（安装时自动选择yes） update</code></pre><h3 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h3><pre><code class="hljs linux">docker ps -a</code></pre><h3 id="暂停容器"><a href="#暂停容器" class="headerlink" title="暂停容器"></a>暂停容器</h3><pre><code class="hljs linux">docker stop &lt;容器ID&gt;</code></pre><h3 id="运行容器（stop的容器再次启动）"><a href="#运行容器（stop的容器再次启动）" class="headerlink" title="运行容器（stop的容器再次启动）"></a>运行容器（stop的容器再次启动）</h3><pre><code class="hljs linux">docker start &lt;容器ID&gt;</code></pre><h3 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h3><pre><code class="hljs linux">docker images</code></pre><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><pre><code class="hljs linux">docker pull +镜像名称</code></pre><h3 id="连接运行的容器"><a href="#连接运行的容器" class="headerlink" title="连接运行的容器"></a>连接运行的容器</h3><pre><code class="hljs linux">docker attach +容器</code></pre><blockquote><p>可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）</p><p>使用 <strong>Ctrl + p + q</strong> 退出，直接使用Ctrl + c会导致容器本身也停止</p></blockquote><h3 id="查看容器运行的进程"><a href="#查看容器运行的进程" class="headerlink" title="查看容器运行的进程"></a>查看容器运行的进程</h3><ul><li>得到PID后，<strong>在宿主机上执行操作</strong></li></ul><pre><code class="hljs linux">docker top +容器名称</code></pre><h3 id="在容器中执行命令"><a href="#在容器中执行命令" class="headerlink" title="在容器中执行命令"></a>在容器中执行命令</h3><pre><code class="hljs linux">docker exec -it &lt;容器ID&gt;  /bin/bash</code></pre><h3 id="从容器创建一个新的镜像"><a href="#从容器创建一个新的镜像" class="headerlink" title="从容器创建一个新的镜像"></a>从容器创建一个新的镜像</h3><pre><code class="hljs linux">docker commit -a "作者名称" -m "携带消息" &lt;容器名&gt; centos（镜像）:ssh（标签）eg:docker commit -a "Gendml" -m "已配置ssh的CentOS7镜像" Gendml_Centos7 centos:ssh</code></pre><h3 id="容器与主机之间的数据拷贝"><a href="#容器与主机之间的数据拷贝" class="headerlink" title="容器与主机之间的数据拷贝"></a>容器与主机之间的数据拷贝</h3><pre><code class="hljs linux">docker cp /www/runoob 96f7f14e99ab:/wwwdocker cp  96f7f14e99ab:/www /tmp/</code></pre><h3 id="容器与宿主映射添加容器卷"><a href="#容器与宿主映射添加容器卷" class="headerlink" title="容器与宿主映射添加容器卷"></a>容器与宿主映射添加容器卷</h3><pre><code class="hljs linux">docker run -itd --privileged=true --name 容器名称 -v /宿主机绝对路径目录:/容器内目录 -p 端口映射 镜像名</code></pre><ul><li>配置读写规则</li><li>默认是读写</li><li>配置只读规则：<code>docker run -it --privileged=true -v/宿主机绝对路径目录:/容器内目录:ro 镜像名</code></li></ul><h3 id="容器2继承容器1的卷规则"><a href="#容器2继承容器1的卷规则" class="headerlink" title="容器2继承容器1的卷规则"></a>容器2继承容器1的卷规则</h3><ul><li>效果：容器之间卷数据映射，无论容器是否运行，实时卷同步</li></ul><pre><code class="hljs linux">docker run-it --privileged=true --volumes-from 父类 --name u2 ubuntu</code></pre><h3 id="Docker导出容器作为tar归档文件"><a href="#Docker导出容器作为tar归档文件" class="headerlink" title="Docker导出容器作为tar归档文件"></a>Docker导出容器作为tar归档文件</h3><pre><code class="hljs linux">docker export -o xxx.tar &lt;容器名称&gt; bash（不加会出bug）</code></pre><h3 id="Docker从归档文件中导入镜像"><a href="#Docker从归档文件中导入镜像" class="headerlink" title="Docker从归档文件中导入镜像"></a>Docker从归档文件中导入镜像</h3><pre><code class="hljs linux">docker import  xxx.tar 镜像名称:标签</code></pre><h3 id="Docker挂载主机目录访问如果出现cannot-open-directory-Permission-denied"><a href="#Docker挂载主机目录访问如果出现cannot-open-directory-Permission-denied" class="headerlink" title="Docker挂载主机目录访问如果出现cannot open directory .: Permission denied"></a>Docker挂载主机目录访问如果出现cannot open directory .: Permission denied</h3><ul><li>解决办法：在挂载目录后多加一个–privileged=true参数即可</li><li>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为</li><li>在SELinux里面挂载目录被禁止掉了额，如果要开启，我们一般使用–privileged=true命令，扩大容器的权限解决挂载目录没有权限的问题，也即使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</li></ul><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><ul><li>Docker网络作用：</li><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ul><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220806221528.png"></p><ul><li><p>bridge模式：使用–network  bridge指定，默认使用docker0</p><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信。</p></li><li><p>host模式：使用–network host指定（-p端口映射失效，开启后要关闭虚拟机的防火墙）</p><p>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</p></li><li><p>none模式：使用–network none指定</p><p>在none模式下，并不为Docker容器进行任何网络配置。 </p><p>也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo</p><p>需要我们自己为Docker容器添加网卡、配置IP等。</p></li><li><p>container模式：使用–network container:NAME或者容器ID（多个容器间通信）</p><p>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><pre><code class="hljs linux">docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</code></pre></li></ul><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><ul><li><strong>Docker的–link参数已经过时，即将被Docker弃用</strong></li><li>Docker容器之间可以通过ip地址ping通</li><li>但是，一旦某个容器宕机，其他新建的容器会占用宕机容器的ip地址，原容器的功能会出现错乱，这对于大型微服务开发是致命的</li><li><strong>自定义网络本身就维护好了主机名和ip的对应关系（ip和域名都能通），容器名称可直接作ip地址使用。</strong></li></ul><pre><code class="hljs linux">docker network create XXX网络名字</code></pre><h4 id="安装ping命令"><a href="#安装ping命令" class="headerlink" title="安装ping命令"></a>安装ping命令</h4><pre><code class="hljs linux">apt-get updateapt install -y iputils-ping</code></pre><h4 id="安装ip-addr命令"><a href="#安装ip-addr命令" class="headerlink" title="安装ip addr命令"></a>安装ip addr命令</h4><pre><code class="hljs linux">apt-get updateapt install -y iproute2</code></pre><h4 id="安装ifconfig命令"><a href="#安装ifconfig命令" class="headerlink" title="安装ifconfig命令"></a>安装ifconfig命令</h4><pre><code class="hljs linux">apt-get updateapt install -y net-tools</code></pre><h4 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h4><pre><code class="hljs linux">docker network ls</code></pre><h4 id="查看单个Docker容器网络地址"><a href="#查看单个Docker容器网络地址" class="headerlink" title="查看单个Docker容器网络地址"></a>查看单个Docker容器网络地址</h4><pre><code class="hljs linux">ip addr</code></pre><h4 id="查看网络源数据"><a href="#查看网络源数据" class="headerlink" title="查看网络源数据"></a>查看网络源数据</h4><pre><code class="hljs linux">docker network inspect  XXX网络名字</code></pre><h4 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h4><pre><code class="hljs linux">docker network rm XXX网络名字</code></pre><h3 id="Docker配置Jetty容器"><a href="#Docker配置Jetty容器" class="headerlink" title="Docker配置Jetty容器"></a>Docker配置Jetty容器</h3><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><pre><code class="hljs linux">docker run -itd --name gendml_jetty --privileged=true --network gendml_net -p 50001:8080 -v /usr/Docker/jetty/webapps:/var/lib/jetty/webapps jetty:9.4.48-jdk8</code></pre><h3 id="Docker配置Nginx容器"><a href="#Docker配置Nginx容器" class="headerlink" title="Docker配置Nginx容器"></a>Docker配置Nginx容器</h3><h4 id="创建容器-1"><a href="#创建容器-1" class="headerlink" title="创建容器"></a>创建容器</h4><pre><code class="hljs linux">docker run -itd --name gendml_nginx_student --privileged=true --network gendml_net -p 50004:9000 -v /usr/Docker/nginx_student/config/nginx.conf:/etc/nginx/nginx.conf -v /usr/Docker/nginx_student/html:/usr/share/nginx/html nginx:1.20.1</code></pre><h3 id="Docker配置JDK18容器"><a href="#Docker配置JDK18容器" class="headerlink" title="Docker配置JDK18容器"></a>Docker配置JDK18容器</h3><h4 id="创建容器-2"><a href="#创建容器-2" class="headerlink" title="创建容器"></a>创建容器</h4><pre><code class="hljs linux">docker run -itd --name gendml_java --privileged=true --network host -v /usr/Docker/java:/usr/java/project openjdk:jdk-oraclelinux8</code></pre><h4 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h4><pre><code class="hljs linux">systemctl status firewalld</code></pre><h4 id="开机关闭防火墙"><a href="#开机关闭防火墙" class="headerlink" title="开机关闭防火墙"></a>开机关闭防火墙</h4><pre><code class="hljs linux">systemctl disable firewalld.service</code></pre><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><pre><code class="hljs linux">systemctl stop firewalld.service</code></pre><h3 id="Docker配置MySQL容器"><a href="#Docker配置MySQL容器" class="headerlink" title="Docker配置MySQL容器"></a>Docker配置MySQL容器</h3><h4 id="创建容器-3"><a href="#创建容器-3" class="headerlink" title="创建容器"></a>创建容器</h4><pre><code class="hljs linux">docker run # 创建容器-itd # 交互式后台运行 --name gendml_mysql # 容器名称--privileged=true # 特权模式，root--network gendml_net # 选择自定义网络-p 50002:3306 # 端口映射（宿主：容器）-e MYSQL_ROOT_PASSWORD=dml666 # MySQL密码-v /usr/Docker/mysql/log:/var/log/mysql # 资源共享-v /usr/Docker/mysql/data:/cvar/lib/mysql # 资源共享-v /usr/Docker/mysql/conf:/etc/mysql/conf.d # 资源共享mysql:5.6.51 # 使用对应镜像创建容器docker run -itd --name gendml_mysql --privileged=true --network gendml_net -p 3306:3306 -e MYSQL_ROOT_PASSWORD=dml666 -v /usr/Docker/mysql/log:/var/log/mysql -v /usr/Docker/mysql/data:/cvar/lib/mysql -v /usr/Docker/mysql/conf:/etc/mysql/conf.d mysql:5.6.51</code></pre><h4 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a>解决中文乱码</h4><pre><code class="hljs linux">cd /usr/Docker/mysql/conf# 在conf文件夹内创建my.cnf# 文件填入如下内容[client]default_character_set=utf8[mysqld]collation_server = utf8_general_cicharacter_set_server = utf8docker restart gendml_mysql</code></pre><h3 id="Docker配置Redis"><a href="#Docker配置Redis" class="headerlink" title="Docker配置Redis"></a>Docker配置Redis</h3><pre><code class="hljs linux">docker run -itd  --privileged=true --name gendml_redis --network gendml_net -p 50003:6379 -v /usr/Docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/Docker/redis/data:/data redis:6.0.8 redis-server /etc/redis/redis.conf</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js基础</title>
      <link href="/2022/08/07/node.js-ji-chu/"/>
      <url>/2022/08/07/node.js-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Node-js"><a href="#一、Node-js" class="headerlink" title="一、Node.js"></a>一、Node.js</h1><h2 id="（一）常用命令"><a href="#（一）常用命令" class="headerlink" title="（一）常用命令"></a>（一）常用命令</h2><h3 id="更改仓库"><a href="#更改仓库" class="headerlink" title="更改仓库"></a>更改仓库</h3><p>这里使用淘宝镜像</p><pre><code class="hljs plaintext">npm config set registry https://registry.npm.taobao.org</code></pre><h3 id="查看当前仓库"><a href="#查看当前仓库" class="headerlink" title="查看当前仓库"></a>查看当前仓库</h3><pre><code class="hljs plaintext">npm config get registry</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令大全</title>
      <link href="/2022/05/17/linux-ming-ling-da-quan/"/>
      <url>/2022/05/17/linux-ming-ling-da-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Lunix系统技术"><a href="#一、Lunix系统技术" class="headerlink" title="一、Lunix系统技术"></a>一、Lunix系统技术</h2><h2 id="（一）常用命令"><a href="#（一）常用命令" class="headerlink" title="（一）常用命令"></a>（一）常用命令</h2><h3 id="链接命令，是给系统中已有的文件指定另一个名称"><a href="#链接命令，是给系统中已有的文件指定另一个名称" class="headerlink" title="链接命令，是给系统中已有的文件指定另一个名称"></a>链接命令，是给系统中已有的文件指定另一个名称</h3><ul><li><p>常用参数-s-f  </p></li><li><p>提示 ln [ 参数 ] 源文件 目的文件</p></li><li><p>例子</p><p>-d硬链接：硬链接文件与原始文件其实是同一个文件，只是名字不同</p><p>-s软链接： 等同于 Windows 系统下的快捷方式。仅仅包括所含链接文件的路径名字。因此能链接目录，也能跨文件系统链接。但是，当删除原始文件后，链接文件也将失效。</p></li><li><p>删除链接：unlink + 链接名</p></li></ul><h3 id="查找命令位置"><a href="#查找命令位置" class="headerlink" title="查找命令位置"></a>查找命令位置</h3><p><code>whereis + 命令</code> </p><h3 id="清除当前终端窗口"><a href="#清除当前终端窗口" class="headerlink" title="清除当前终端窗口"></a>清除当前终端窗口</h3><p><code>clear</code></p><h3 id="查看当前目录"><a href="#查看当前目录" class="headerlink" title="查看当前目录"></a>查看当前目录</h3><ul><li>查看名称：<code>ls</code></li><li>详细查看：<code>ll</code></li></ul><h3 id="显示当前位置"><a href="#显示当前位置" class="headerlink" title="显示当前位置"></a>显示当前位置</h3><p><code>pwd</code></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>sudo tar -xvzf  + 文件地址</code></p><h3 id="退出命令行"><a href="#退出命令行" class="headerlink" title="退出命令行"></a>退出命令行</h3><p><code>ctrl+z</code></p><h3 id="改变权限命令"><a href="#改变权限命令" class="headerlink" title="改变权限命令"></a>改变权限命令</h3><ul><li>常用参数：（1＝执行权 2＝写权 4＝读权 1＋2＝3 执行和写权，以此类推）</li><li> 提示：chmod 参数 文件或目录名 </li></ul><h3 id="将文件和目录从一个目录拷贝到另一个目录"><a href="#将文件和目录从一个目录拷贝到另一个目录" class="headerlink" title="将文件和目录从一个目录拷贝到另一个目录"></a>将文件和目录从一个目录拷贝到另一个目录</h3><ul><li><p> 常用参数：-i-f-r</p></li><li><p>提示：cp [ 参数 ] 源文件或目录 目的文件或目录</p><p>-i当目标文件存在时，系统提示是否拷贝</p><p>-f目标文件存在时不给提示直接拷贝 </p><p>-r拷贝这个目录及目录里的所有文件和子目录 </p></li></ul><h3 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h3><p><code>shutdown</code></p><p><code>reboot</code></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><p>vim + 文件路径 -&gt; i键表示插入修改 -&gt; 当插入完成，点击esc，接着英文状态下 shift+:  ,左下方显示冒号。输入wq!强制保存退出</p><h4 id="移动文件-重命名"><a href="#移动文件-重命名" class="headerlink" title="移动文件/重命名"></a>移动文件/重命名</h4><p><code>mv 【源文件路径】 【目的文件路径】</code></p><h4 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h4><p><code>find / -name + 【文件路径】</code></p><h4 id="查找文件中的指定字符"><a href="#查找文件中的指定字符" class="headerlink" title="查找文件中的指定字符"></a>查找文件中的指定字符</h4><p>查看sneakers.txt文件中”coffee”的位置：grep coffee sneakers.txt</p><p>你就会看到文件中带有“coffee”的每一行。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p><code>rm -rf + 【文件路径】</code></p><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><h4 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h4><p><code>rm -rf + 【文件夹】</code></p><h4 id="进入某文件夹"><a href="#进入某文件夹" class="headerlink" title="进入某文件夹"></a>进入某文件夹</h4><p><code>cd + 【文件路径】</code></p><h4 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h4><p><code>mkdir + 【文件路径】</code></p><h4 id="移动文件夹-重命名"><a href="#移动文件夹-重命名" class="headerlink" title="移动文件夹/重命名"></a>移动文件夹/重命名</h4><p><code>mv 【源文件路径】 【目的文件路径】</code></p><h2 id="（二）进阶命令"><a href="#（二）进阶命令" class="headerlink" title="（二）进阶命令"></a>（二）进阶命令</h2><h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><p>是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。提供了查找、安装、删除某一个、一组甚至全部软件包的命令。</p><h4 id="yum语法："><a href="#yum语法：" class="headerlink" title="yum语法："></a><strong>yum语法：</strong></h4><pre><code class="hljs plaintext">yum [options] [command] [package ...]</code></pre><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><h4 id="yum常用命令："><a href="#yum常用命令：" class="headerlink" title="yum常用命令："></a><strong>yum常用命令：</strong></h4><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong></li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：**yum install **</li><li>仅更新指定的软件命令：**yum update **</li><li>列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>删除软件包命令：**yum remove **</li><li>查找软件包命令：**yum search **</li><li>清除缓存命令:<ul><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul></li></ul><h3 id="apt命令"><a href="#apt命令" class="headerlink" title="apt命令"></a>apt命令</h3><p>在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。提供了查找、安装、删除某一个、一组甚至全部软件包的命令。</p><h4 id="apt-语法："><a href="#apt-语法：" class="headerlink" title="apt 语法："></a><strong>apt 语法：</strong></h4><pre><code class="hljs plaintext">apt [options] [command] [package ...]</code></pre><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><h4 id="apt常用命令："><a href="#apt常用命令：" class="headerlink" title="apt常用命令："></a><strong>apt常用命令：</strong></h4><ul><li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p></li><li><p>升级软件包：<strong>sudo apt upgrade</strong></p><p>列出可更新的软件包及版本信息：<strong>apt list –upgradeable</strong></p><p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p></li><li><p>安装指定的软件命令：**sudo apt install **</p><p>安装多个软件包：**sudo apt install   **</p></li><li><p>更新指定的软件命令：**sudo apt update **</p></li><li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：**sudo apt show **</p></li><li><p>删除软件包命令：**sudo apt remove **</p></li><li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p></li><li><p>移除软件包及配置文件: **sudo apt purge **</p></li><li><p>查找软件包命令： **sudo apt search **</p></li><li><p>列出所有已安装的包：<strong>apt list –installed</strong></p></li><li><p>列出所有已安装的包的版本信息：<strong>apt list –all-versions</strong></p></li></ul><h3 id="加载到环境变量"><a href="#加载到环境变量" class="headerlink" title="加载到环境变量"></a>加载到环境变量</h3><p><code>source + .sh文件</code></p><h3 id="下载命令"><a href="#下载命令" class="headerlink" title="下载命令"></a>下载命令</h3><p>下载并以不同的文件名保存</p><pre><code class="hljs linux">wget -O [name] [下载链接URL]</code></pre><p>例如：</p><pre><code class="hljs plaintext">wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080</code></pre><h3 id="查看进程以及对应进程号"><a href="#查看进程以及对应进程号" class="headerlink" title="查看进程以及对应进程号"></a>查看进程以及对应进程号</h3><p><code>jps</code></p><h3 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h3><p><code>top</code></p><blockquote><p>通过按键<strong>”E</strong>“更换内存的单位（kb, mb, gb, tb …）</p></blockquote><h3 id="结束某个进程"><a href="#结束某个进程" class="headerlink" title="结束某个进程"></a>结束某个进程</h3><p><code>kill -9 + 进程号</code> </p><h3 id="后台挂起"><a href="#后台挂起" class="headerlink" title="后台挂起"></a>后台挂起</h3><p><code>nohup java -jar jar包 &gt;err.out（输出错误日志）&amp; （让bash在后台运行）</code></p><h3 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h3><p><code>java -jar   +jar包名称</code></p><h3 id="查看所有端口进程"><a href="#查看所有端口进程" class="headerlink" title="查看所有端口进程"></a>查看所有端口进程</h3><p><code>netstat -nlp</code></p><h3 id="检查文件系统的空间占用情况"><a href="#检查文件系统的空间占用情况" class="headerlink" title="检查文件系统的空间占用情况"></a>检查文件系统的空间占用情况</h3><p><code>df</code> </p><h3 id="maven命令运行boot项目"><a href="#maven命令运行boot项目" class="headerlink" title="maven命令运行boot项目"></a>maven命令运行boot项目</h3><p>前提：安装Maven3.2.2（Windows上是此版本）</p><p><code>mvn spring-boot:run</code></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry Pi使用总结</title>
      <link href="/2022/05/17/raspberry-pi-shi-yong-zong-jie/"/>
      <url>/2022/05/17/raspberry-pi-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="一、树莓派常用命令"><a href="#一、树莓派常用命令" class="headerlink" title="一、树莓派常用命令"></a>一、树莓派常用命令</h1><h2 id="打开树莓派配置"><a href="#打开树莓派配置" class="headerlink" title="打开树莓派配置"></a>打开树莓派配置</h2><pre><code class="hljs linx">sudo raspi-config</code></pre><h2 id="立即关机"><a href="#立即关机" class="headerlink" title="立即关机"></a>立即关机</h2><pre><code class="hljs linx">shutdown -h now</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code class="hljs linx">sudo reboot</code></pre><h2 id="查看插入设备的USB口"><a href="#查看插入设备的USB口" class="headerlink" title="查看插入设备的USB口"></a>查看插入设备的USB口</h2><pre><code class="hljs linux">lsusb</code></pre><h2 id="查看摄像头设备名"><a href="#查看摄像头设备名" class="headerlink" title="查看摄像头设备名"></a>查看摄像头设备名</h2><pre><code class="hljs linux">ls /dev/video*</code></pre><h2 id="查看树莓派端口"><a href="#查看树莓派端口" class="headerlink" title="查看树莓派端口"></a>查看树莓派端口</h2><pre><code class="hljs ;inx">ls -l /dev/tty*</code></pre>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raspberry Pi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习系列笔记</title>
      <link href="/2022/05/17/shen-du-xue-xi-xi-lie-bi-ji/"/>
      <url>/2022/05/17/shen-du-xue-xi-xi-lie-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="1、梯度下降法"><a href="#1、梯度下降法" class="headerlink" title="1、梯度下降法"></a>1、梯度下降法</h1><h2 id="1-1梯度"><a href="#1-1梯度" class="headerlink" title="1.1梯度"></a>1.1梯度</h2><p>梯度是函数增长最快的方向，梯度的模为这一方向的变化率。</p><p>对于一元函数求梯度，公式为:<br>$$<br>\frac{d y}{d x}=f^{\prime}(x)=\lim _{\Delta x \rightarrow 0} \frac{\mathrm{f}(\mathrm{x}+\Delta x)-f(x)}{\Delta x}<br>$$<br>很显然，该函数的梯度为一条<strong>切线</strong>。</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220326213334951.png" alt="image-20220326213334951" style="zoom: 33%;"><p>而对于多维函数，比如f(x,y)，此函数的梯度为一个<strong>切面</strong>。</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220326213602608.png" alt="image-20220326213602608" style="zoom:33%;"><p>如果再进行维度拓展，将无法进行求解，科学家通过引入<strong>偏导</strong>，求解梯度：</p><h2 id="1-2梯度下降法思路"><a href="#1-2梯度下降法思路" class="headerlink" title="1.2梯度下降法思路"></a>1.2梯度下降法思路</h2><p>找到函数的梯度，在此方向取负梯度，函数下降的最快，进而找到函数的最小值，一般用于求解损失函数的最小值，优化模型。</p><h1 id="2、Python中的广播"><a href="#2、Python中的广播" class="headerlink" title="2、Python中的广播"></a>2、Python中的广播</h1><h2 id="2-1广播案例"><a href="#2-1广播案例" class="headerlink" title="2.1广播案例"></a>2.1广播案例</h2><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220329214513085.png" alt="image-20220329214513085" style="zoom: 33%;"><p>当两个矩阵相加，在不符合线性代数矩阵运算时，矩阵会自动扩展结构，然后执行运算</p><h2 id="2-2Numpy中的广播机制"><a href="#2-2Numpy中的广播机制" class="headerlink" title="2.2Numpy中的广播机制"></a>2.2Numpy中的广播机制</h2><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 <strong>a.shape == b.shape</strong>，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><p>实例:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  a = np.array([[ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],           [<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>],           [<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>],           [<span class="hljs-number">30</span>,<span class="hljs-number">30</span>,<span class="hljs-number">30</span>]])b = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<span class="hljs-built_in">print</span>(a + b)</code></pre><p>输出结果：</p><pre><code class="hljs python">[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>] [<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span>] [<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>] [<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span>]]</code></pre><p>下面的图片展示了数组 b 如何通过广播来与数组 a 兼容。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image0020619.gif" alt="img"></p><h1 id="3、最小二乘法"><a href="#3、最小二乘法" class="headerlink" title="3、最小二乘法"></a>3、最小二乘法</h1><h2 id="3-1什么是线性回归？"><a href="#3-1什么是线性回归？" class="headerlink" title="3.1什么是线性回归？"></a>3.1什么是线性回归？</h2><p>比如，在二维空间中，线性回归就是要找一条直线，并且让这条直线尽可能拟合图中的数据点</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220330160837326.png" alt="image-20220330160837326" style="zoom: 67%;"><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220330160919509.png" alt="image-20220330160919509" style="zoom:67%;"><p>每条红色竖线是预测数据到真实数据的差距（误差），称为欧氏距离，然后将这些误差加起来，就得到线性回归的损失函数。<br>$$<br>\sum_{i=0}^{m} (y^{(i)} - \hat{y}  ^{(i)} )^{^{2} }<br>$$</p><h2 id="3-2最小二乘法"><a href="#3-2最小二乘法" class="headerlink" title="3.2最小二乘法"></a>3.2最小二乘法</h2><p><a href="https://www.zhihu.com/topic/19668117/intro">见知乎专栏</a></p><p><strong>在实际观测时，考虑到观测值带有偶然误差，总是作多余观测</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613001311.png"></p><h1 id="4、最大似然估计"><a href="#4、最大似然估计" class="headerlink" title="4、最大似然估计"></a>4、最大似然估计</h1><p><a href="https://zhuanlan.zhihu.com/p/55791843">见知乎专栏</a></p><p>最大似然估计可以说是应用非常广泛的一种参数估计的方法。它的原理也很简单：利用已知的样本，找出最有可能生成该样本的参数。</p><h2 id="4-1什么是似然函数？"><a href="#4-1什么是似然函数？" class="headerlink" title="4.1什么是似然函数？"></a>4.1什么是似然函数？</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613000609.png"></p><h2 id="4-2最大似然估计"><a href="#4-2最大似然估计" class="headerlink" title="4.2最大似然估计"></a>4.2最大似然估计</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613000628.png"></p><h2 id="4-3离散型随机变量的最大似然估计"><a href="#4-3离散型随机变量的最大似然估计" class="headerlink" title="4.3离散型随机变量的最大似然估计"></a>4.3离散型随机变量的最大似然估计</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613001346.png"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613001434.png"><br>$$<br>C_{n}^{k} = \frac{n!}{k!(n-k)!}是二项式系数，我们希望有k次成功(p)和n−k次失败(1 −p)，并且，k次成功可以在n次试验的任何地方出现，而把k次成功分布在n次试验中共有C_{n}^{k}个不同的方法。<br>$$</p><h2 id="4-4连续型随机变量的最大似然估计"><a href="#4-4连续型随机变量的最大似然估计" class="headerlink" title="4.4连续型随机变量的最大似然估计"></a>4.4连续型随机变量的最大似然估计</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613001521.png"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-0012043fca529a0c5a88a1425ccf48dc_720w.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/20220613001655.png"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-4acb983eefed903c9da719cef00a7745_720w.jpg" alt="img"></p><h1 id="5、Logistic回归"><a href="#5、Logistic回归" class="headerlink" title="5、Logistic回归"></a>5、Logistic回归</h1><h2 id="5-1Logistic回归"><a href="#5-1Logistic回归" class="headerlink" title="5.1Logistic回归"></a>5.1Logistic回归</h2><p>如下图所示，计算节点值z，再通过激活函数sigmoid()求出a，a为到该节点的输出，如下图。</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401173054150.png" alt="image-20220401173054150" style="zoom: 50%;"><h2 id="5-2Logistic回归再在神经网络的应用"><a href="#5-2Logistic回归再在神经网络的应用" class="headerlink" title="5.2Logistic回归再在神经网络的应用"></a>5.2Logistic回归再在神经网络的应用</h2><p>神经网络正向传播中执行了很多次类似Logistic回归的操作，如下图所示，每个节点执行了一次Logistic回归，舍弃for循环，通过矩阵运算快速计算出z（用z[1]表示）和a（用a[1]表示）。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401174013810.png" alt="image-20220401174013810"></p><p>计算完隐藏层节点的值后，再作为输入计算输出层的值。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401175106812.png" alt="image-20220401175106812"></p><h2 id="5-3推导过程"><a href="#5-3推导过程" class="headerlink" title="5.3推导过程"></a>5.3推导过程</h2><p>见：<a href="https://www.bilibili.com/video/BV1aE411o7qd?p=17">BiliBili讲解</a></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220330224031997.png" alt="image-20220330224031997"></p><p>涉及到0/1的二分类问题，通过Sigmoid函数表示出1和0的发生概率，使用最大似然估计法，最后求导得出使得概率最大的参数值。</p><h1 id="6、激活函数"><a href="#6、激活函数" class="headerlink" title="6、激活函数"></a>6、激活函数</h1><p>在构建神经网络的时候，如何选择激活函数？此过程往往有很多的参数选择，通过测试的方法，找到一个最适合自己的激活函数，调参。</p><h2 id="6-1Sigmoid函数"><a href="#6-1Sigmoid函数" class="headerlink" title="6.1Sigmoid函数"></a>6.1Sigmoid函数</h2><p>除非用在二元分类的输出层，不然绝对不要用。</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401212246481.png" alt="image-20220401212246481" style="zoom: 50%;"><h2 id="6-2tanh函数"><a href="#6-2tanh函数" class="headerlink" title="6.2tanh函数"></a>6.2tanh函数</h2><p>几乎在所有场合都适用。</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401212426016.png" alt="image-20220401212426016" style="zoom: 50%;"><h2 id="6-3ReLu函数"><a href="#6-3ReLu函数" class="headerlink" title="6.3ReLu函数"></a>6.3ReLu函数</h2><p>不知道用哪个的时候，用这个</p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401212550526.png" alt="image-20220401212550526" style="zoom:50%;"><h2 id="6-4Leaky-ReLu函数"><a href="#6-4Leaky-ReLu函数" class="headerlink" title="6.4Leaky ReLu函数"></a>6.4Leaky ReLu函数</h2><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20220401212839258.png" alt="image-20220401212839258" style="zoom:50%;"><h1 id="附：数学公式"><a href="#附：数学公式" class="headerlink" title="附：数学公式"></a>附：数学公式</h1><h2 id="求和公式"><a href="#求和公式" class="headerlink" title="求和公式"></a>求和公式</h2><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/image-20211227103823765.png" alt="image-20211227103823765" style="zoom: 80%;"><h1 id="附：数学符号"><a href="#附：数学符号" class="headerlink" title="附：数学符号"></a>附：数学符号</h1><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul><li>x：标量</li><li>x：向量</li><li>X：矩阵</li><li>X：张量</li><li>I：单位矩阵</li><li>xi, [x]i：向量x第i个元素</li><li>xij, [X]ij：矩阵X第i行第j列的元素</li></ul><h2 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h2><ul><li>X: 集合</li><li>Z: 整数集合</li><li>R: 实数集合</li><li>Rn: n维实数向量</li><li>Ra×b: 包含a行和b列的实数矩阵</li><li>A∪B: 集合A和B的并集</li><li>A∩B：集合A和B的交集</li><li>A∖B：集合A与集合B相减，B关于A的相对补集</li></ul><h2 id="函数和运算符"><a href="#函数和运算符" class="headerlink" title="函数和运算符"></a>函数和运算符</h2><ul><li>f(⋅)：函数</li><li>log⁡(⋅)：自然对数</li><li>exp⁡(⋅): 指数函数</li><li>1X: 指示函数</li><li>(⋅)⊤: 向量或矩阵的转置</li><li>X−1: 矩阵的逆</li><li>⊙: 按元素相乘</li><li>[⋅,⋅]：连结</li><li>|X|：集合的基数</li><li>‖⋅‖p: ：Lp 正则</li><li>‖⋅‖: L2 正则</li><li>⟨x,y⟩：向量x和y的点积</li><li>∑: 连加</li><li>∏: 连乘</li><li>=def：定义</li></ul><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><ul><li>dydx：y关于x的导数</li><li>∂y∂x：y关于x的偏导数</li><li>∇xy：y关于x的梯度</li><li>∫abf(x)dx: f在a到b区间上关于x的定积分</li><li>∫f(x)dx: f关于x的不定积分</li></ul><h2 id="概率与信息论"><a href="#概率与信息论" class="headerlink" title="概率与信息论"></a>概率与信息论</h2><ul><li>P(⋅)：概率分布</li><li>z∼P: 随机变量z具有概率分布P</li><li>P(X∣Y)：X∣Y的条件概率</li><li>p(x): 概率密度函数</li><li>Ex[f(x)]: 函数f对x的数学期望</li><li>X⊥Y: 随机变量X和Y是独立的</li><li>X⊥Y∣Z: 随机变量X和Y在给定随机变量Z的条件下是独立的</li><li>Var(X): 随机变量X的方差</li><li>σX: 随机变量X的标准差</li><li>Cov(X,Y): 随机变量X和Y的协方差</li><li>ρ(X,Y): 随机变量X和Y的相关性</li><li>H(X): 随机变量X的熵</li><li>DKL(P‖Q): P和Q的KL-散度</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>O：大O标记</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架基础</title>
      <link href="/2022/05/17/springmvc-kuang-jia-ji-chu/"/>
      <url>/2022/05/17/springmvc-kuang-jia-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="一、SpringMVC简介"><a href="#一、SpringMVC简介" class="headerlink" title="一、SpringMVC简介"></a>一、SpringMVC简介</h1><h3 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><p>M：Model，模型层，指工程中的JavaBean，作用是处理数据</p><p>JavaBean分为两类：</p><ul><li>一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</li><li>一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li></ul><p>V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p><p>C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p><blockquote><p>MVC的工作流程：<br><strong>用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器</strong></p></blockquote><h3 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h3><p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p><p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</p><blockquote><p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet</p></blockquote><h3 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h3><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h1 id="二、HelloWorld"><a href="#二、HelloWorld" class="headerlink" title="二、HelloWorld"></a>二、HelloWorld</h1><h3 id="1、开发环境"><a href="#1、开发环境" class="headerlink" title="1、开发环境"></a>1、开发环境</h3><p>IDE：idea 2019.2</p><p>构建工具：maven3.5.4</p><p>服务器：tomcat7</p><p>Spring版本：5.3.1</p><h3 id="2、创建maven工程"><a href="#2、创建maven工程" class="headerlink" title="2、创建maven工程"></a>2、创建maven工程</h3><h5 id="a-gt-添加web模块"><a href="#a-gt-添加web模块" class="headerlink" title="a>添加web模块"></a>a&gt;添加web模块</h5><h5 id="b-gt-打包方式：war"><a href="#b-gt-打包方式：war" class="headerlink" title="b>打包方式：war"></a>b&gt;打包方式：war</h5><h5 id="c-gt-引入依赖"><a href="#c-gt-引入依赖" class="headerlink" title="c>引入依赖"></a>c&gt;引入依赖</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!-- SpringMVC --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 日志 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- ServletAPI --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="/2022/05/17/springmvc-kuang-jia-ji-chu/Documents/Desktop/GuiGu/Springboot2/笔记/img/img001.png" alt="images"></p><h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><p>注册SpringMVC的前端控制器DispatcherServlet</p><h5 id="a-gt-默认配置方式"><a href="#a-gt-默认配置方式" class="headerlink" title="a>默认配置方式"></a>a&gt;默认配置方式</h5><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><h5 id="b-gt-扩展配置方式"><a href="#b-gt-扩展配置方式" class="headerlink" title="b>扩展配置方式"></a>b&gt;扩展配置方式</h5><p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">         作为框架的核心组件，在启动过程中有大量的初始化操作要做</span><span class="hljs-comment">        而这些操作放在第一次请求时才执行会严重影响访问速度</span><span class="hljs-comment">        因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span><span class="hljs-comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span><span class="hljs-comment">        但是/不能匹配.jsp请求路径的请求</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span></code></pre><blockquote><p>注：</p><p>&lt;url-pattern&gt;标签中使用/和/*的区别：</p><p>/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法</p></blockquote><h3 id="4、创建请求控制器"><a href="#4、创建请求控制器" class="headerlink" title="4、创建请求控制器"></a>4、创建请求控制器</h3><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器</p><p>请求控制器中每一个处理请求的方法成为控制器方法</p><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloController</span> {    }</code></pre><h3 id="5、创建springMVC的配置文件"><a href="#5、创建springMVC的配置文件" class="headerlink" title="5、创建springMVC的配置文件"></a>5、创建springMVC的配置文件</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 自动扫描包 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"com.atguigu.mvc.controller"</span>/&gt;</span><span class="hljs-comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"viewResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.thymeleaf.spring5.view.ThymeleafViewResolver"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"order"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"characterEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"templateEngine"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.thymeleaf.spring5.SpringTemplateEngine"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"templateResolver"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"</span>&gt;</span>                        <span class="hljs-comment">&lt;!-- 视图前缀 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/WEB-INF/templates/"</span>/&gt;</span>                        <span class="hljs-comment">&lt;!-- 视图后缀 --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"suffix"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".html"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"templateMode"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"HTML5"</span>/&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"characterEncoding"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><span class="hljs-comment">&lt;!-- </span><span class="hljs-comment">   处理静态资源，例如html、js、css、jpg</span><span class="hljs-comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span><span class="hljs-comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span><span class="hljs-comment"> --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><span class="hljs-comment">&lt;!-- 开启mvc注解驱动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.http.converter.StringHttpMessageConverter"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"defaultCharset"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"supportedMediaTypes"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>text/html<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>application/json<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span></code></pre><h3 id="6、测试HelloWorld"><a href="#6、测试HelloWorld" class="headerlink" title="6、测试HelloWorld"></a>6、测试HelloWorld</h3><h5 id="a-gt-实现对首页的访问"><a href="#a-gt-实现对首页的访问" class="headerlink" title="a>实现对首页的访问"></a>a&gt;实现对首页的访问</h5><p>在请求控制器中创建处理请求的方法</p><pre><code class="hljs java"><span class="hljs-comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span><span class="hljs-comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span><span class="hljs-comment">// localhost:8080/springMVC/</span><span class="hljs-meta">@RequestMapping("/")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span> {    <span class="hljs-comment">//设置视图名称</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;}</code></pre><h5 id="b-gt-通过超链接跳转到指定页面"><a href="#b-gt-通过超链接跳转到指定页面" class="headerlink" title="b>通过超链接跳转到指定页面"></a>b&gt;通过超链接跳转到指定页面</h5><p>在主页index.html中设置超链接</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/hello}"</span>&gt;</span>HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>在请求控制器中创建处理请求的方法</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/hello")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">HelloWorld</span><span class="hljs-params">()</span> {    <span class="hljs-keyword">return</span> <span class="hljs-string">"target"</span>;}</code></pre><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p><h1 id="三、-RequestMapping注解"><a href="#三、-RequestMapping注解" class="headerlink" title="三、@RequestMapping注解"></a>三、@RequestMapping注解</h1><h3 id="1、-RequestMapping注解的功能"><a href="#1、-RequestMapping注解的功能" class="headerlink" title="1、@RequestMapping注解的功能"></a>1、@RequestMapping注解的功能</h3><p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p><h3 id="2、-RequestMapping注解的位置"><a href="#2、-RequestMapping注解的位置" class="headerlink" title="2、@RequestMapping注解的位置"></a>2、@RequestMapping注解的位置</h3><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping("/test")</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestMappingController</span> {    <span class="hljs-comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span>    <span class="hljs-meta">@RequestMapping("/testRequestMapping")</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestMapping</span><span class="hljs-params">()</span>{        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;    }}</code></pre><h3 id="3、-RequestMapping注解的value属性"><a href="#3、-RequestMapping注解的value属性" class="headerlink" title="3、@RequestMapping注解的value属性"></a>3、@RequestMapping注解的value属性</h3><p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p><p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p><p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/testRequestMapping}"</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/test}"</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><span class="hljs-meta">        value = {"/testRequestMapping", "/test"}</span><span class="hljs-meta">)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestMapping</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="4、-RequestMapping注解的method属性"><a href="#4、-RequestMapping注解的method属性" class="headerlink" title="4、@RequestMapping注解的method属性"></a>4、@RequestMapping注解的method属性</h3><p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p><p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求</p><p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/test}"</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/test}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><span class="hljs-meta">        value = {"/testRequestMapping", "/test"},</span><span class="hljs-meta">        method = {RequestMethod.GET, RequestMethod.POST}</span><span class="hljs-meta">)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestMapping</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h3 id="5、-RequestMapping注解的params属性（了解）"><a href="#5、-RequestMapping注解的params属性（了解）" class="headerlink" title="5、@RequestMapping注解的params属性（了解）"></a>5、@RequestMapping注解的params属性（了解）</h3><p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p><p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p><p>“param”：要求请求映射所匹配的请求必须携带param请求参数</p><p>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</p><p>“param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value</p><p>“param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/test(username='admin',password=123456)"</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(</span><span class="hljs-meta">        value = {"/testRequestMapping", "/test"}</span><span class="hljs-meta">        ,method = {RequestMethod.GET, RequestMethod.POST}</span><span class="hljs-meta">        ,params = {"username","password!=123456"}</span><span class="hljs-meta">)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestMapping</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456}</p></blockquote><h3 id="6、-RequestMapping注解的headers属性（了解）"><a href="#6、-RequestMapping注解的headers属性（了解）" class="headerlink" title="6、@RequestMapping注解的headers属性（了解）"></a>6、@RequestMapping注解的headers属性（了解）</h3><p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p><p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系</p><p>“header”：要求请求映射所匹配的请求必须携带header请求头信息</p><p>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</p><p>“header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p><p>“header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p><h3 id="7、SpringMVC支持ant风格的路径"><a href="#7、SpringMVC支持ant风格的路径" class="headerlink" title="7、SpringMVC支持ant风格的路径"></a>7、SpringMVC支持ant风格的路径</h3><p>？：表示任意的单个字符</p><p>*：表示任意的0个或多个字符</p><p>**：表示任意的一层或多层目录</p><p>注意：在使用**时，只能使用/**/xxx的方式</p><h3 id="8、SpringMVC支持路径中的占位符（重点）"><a href="#8、SpringMVC支持路径中的占位符（重点）" class="headerlink" title="8、SpringMVC支持路径中的占位符（重点）"></a>8、SpringMVC支持路径中的占位符（重点）</h3><p>原始方式：/deleteUser?id=1</p><p>rest方式：/deleteUser/1</p><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/testRest/1/admin}"</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testRest/{id}/{username}")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRest</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> String id, <span class="hljs-meta">@PathVariable("username")</span> String username)</span>{    System.out.println(<span class="hljs-string">"id:"</span>+id+<span class="hljs-string">",username:"</span>+username);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}<span class="hljs-comment">//最终输出的内容为--&gt;id:1,username:admin</span></code></pre><h1 id="四、SpringMVC获取请求参数"><a href="#四、SpringMVC获取请求参数" class="headerlink" title="四、SpringMVC获取请求参数"></a>四、SpringMVC获取请求参数</h1><h3 id="1、通过ServletAPI获取"><a href="#1、通过ServletAPI获取" class="headerlink" title="1、通过ServletAPI获取"></a>1、通过ServletAPI获取</h3><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testParam")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam</span><span class="hljs-params">(HttpServletRequest request)</span>{    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"username"</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">"password"</span>);    System.out.println(<span class="hljs-string">"username:"</span>+username+<span class="hljs-string">",password:"</span>+password);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="2、通过控制器方法的形参获取请求参数"><a href="#2、通过控制器方法的形参获取请求参数" class="headerlink" title="2、通过控制器方法的形参获取请求参数"></a>2、通过控制器方法的形参获取请求参数</h3><p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/testParam(username='admin',password=123456)}"</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testParam")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testParam</span><span class="hljs-params">(String username, String password)</span>{    System.out.println(<span class="hljs-string">"username:"</span>+username+<span class="hljs-string">",password:"</span>+password);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><blockquote><p>注：</p><p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数</p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h3 id="3、-RequestParam（常用）"><a href="#3、-RequestParam（常用）" class="headerlink" title="3、@RequestParam（常用）"></a>3、@RequestParam（常用）</h3><p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p><p>@RequestParam注解一共有三个属性：</p><p>value：指定为形参赋值的请求参数的参数名</p><p>required：设置是否必须传输此请求参数，默认值为true</p><p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null</p><p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</p><h3 id="4、-RequestHeader"><a href="#4、-RequestHeader" class="headerlink" title="4、@RequestHeader"></a>4、@RequestHeader</h3><p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p><p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="5、-CookieValue"><a href="#5、-CookieValue" class="headerlink" title="5、@CookieValue"></a>5、@CookieValue</h3><p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p><p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p><h3 id="6、通过POJO获取请求参数"><a href="#6、通过POJO获取请求参数" class="headerlink" title="6、通过POJO获取请求参数"></a>6、通过POJO获取请求参数</h3><p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/testpojo}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    性别：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"男"</span>&gt;</span>男<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"女"</span>&gt;</span>女<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"age"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    邮箱：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testpojo")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testPOJO</span><span class="hljs-params">(User user)</span>{    System.out.println(user);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}<span class="hljs-comment">//最终结果--&gt;User{id=null, username='张三', password='123', age=23, sex='男', email='123@qq.com'}</span></code></pre><h3 id="7、解决获取请求参数的乱码问题"><a href="#7、解决获取请求参数的乱码问题" class="headerlink" title="7、解决获取请求参数的乱码问题"></a>7、解决获取请求参数的乱码问题</h3><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置springMVC的编码过滤器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><blockquote><p>注：</p><p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p></blockquote><h1 id="五、域对象共享数据"><a href="#五、域对象共享数据" class="headerlink" title="五、域对象共享数据"></a>五、域对象共享数据</h1><h3 id="1、使用ServletAPI向request域对象共享数据"><a href="#1、使用ServletAPI向request域对象共享数据" class="headerlink" title="1、使用ServletAPI向request域对象共享数据"></a>1、使用ServletAPI向request域对象共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testServletAPI")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testServletAPI</span><span class="hljs-params">(HttpServletRequest request)</span>{    request.setAttribute(<span class="hljs-string">"testScope"</span>, <span class="hljs-string">"hello,servletAPI"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="2、使用ModelAndView向request域对象共享数据"><a href="#2、使用ModelAndView向request域对象共享数据" class="headerlink" title="2、使用ModelAndView向request域对象共享数据"></a>2、使用ModelAndView向request域对象共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testModelAndView")</span><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testModelAndView</span><span class="hljs-params">()</span>{    <span class="hljs-comment">/**</span><span class="hljs-comment">     * ModelAndView有Model和View的功能</span><span class="hljs-comment">     * Model主要用于向请求域共享数据</span><span class="hljs-comment">     * View主要用于设置视图，实现页面跳转</span><span class="hljs-comment">     */</span>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();    <span class="hljs-comment">//向请求域共享数据</span>    mav.addObject(<span class="hljs-string">"testScope"</span>, <span class="hljs-string">"hello,ModelAndView"</span>);    <span class="hljs-comment">//设置视图，实现页面跳转</span>    mav.setViewName(<span class="hljs-string">"success"</span>);    <span class="hljs-keyword">return</span> mav;}</code></pre><h3 id="3、使用Model向request域对象共享数据"><a href="#3、使用Model向request域对象共享数据" class="headerlink" title="3、使用Model向request域对象共享数据"></a>3、使用Model向request域对象共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testModel")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testModel</span><span class="hljs-params">(Model model)</span>{    model.addAttribute(<span class="hljs-string">"testScope"</span>, <span class="hljs-string">"hello,Model"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="4、使用map向request域对象共享数据"><a href="#4、使用map向request域对象共享数据" class="headerlink" title="4、使用map向request域对象共享数据"></a>4、使用map向request域对象共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testMap")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span>{    map.put(<span class="hljs-string">"testScope"</span>, <span class="hljs-string">"hello,Map"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="5、使用ModelMap向request域对象共享数据"><a href="#5、使用ModelMap向request域对象共享数据" class="headerlink" title="5、使用ModelMap向request域对象共享数据"></a>5、使用ModelMap向request域对象共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testModelMap")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testModelMap</span><span class="hljs-params">(ModelMap modelMap)</span>{    modelMap.addAttribute(<span class="hljs-string">"testScope"</span>, <span class="hljs-string">"hello,ModelMap"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="6、Model、ModelMap、Map的关系"><a href="#6、Model、ModelMap、Map的关系" class="headerlink" title="6、Model、ModelMap、Map的关系"></a>6、Model、ModelMap、Map的关系</h3><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p><pre><code class="hljs plaintext">public interface Model{}public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {}public class ExtendedModelMap extends ModelMap implements Model {}public class BindingAwareModelMap extends ExtendedModelMap {}</code></pre><h3 id="7、向session域共享数据"><a href="#7、向session域共享数据" class="headerlink" title="7、向session域共享数据"></a>7、向session域共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testSession")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSession</span><span class="hljs-params">(HttpSession session)</span>{    session.setAttribute(<span class="hljs-string">"testSessionScope"</span>, <span class="hljs-string">"hello,session"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h3 id="8、向application域共享数据"><a href="#8、向application域共享数据" class="headerlink" title="8、向application域共享数据"></a>8、向application域共享数据</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testApplication")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testApplication</span><span class="hljs-params">(HttpSession session)</span>{    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">application</span> <span class="hljs-operator">=</span> session.getServletContext();    application.setAttribute(<span class="hljs-string">"testApplicationScope"</span>, <span class="hljs-string">"hello,application"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><h1 id="六、SpringMVC的视图"><a href="#六、SpringMVC的视图" class="headerlink" title="六、SpringMVC的视图"></a>六、SpringMVC的视图</h1><p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p><p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p><p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p><p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</p><h3 id="1、ThymeleafView"><a href="#1、ThymeleafView" class="headerlink" title="1、ThymeleafView"></a>1、ThymeleafView</h3><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testHello")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testHello</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="/2022/05/17/springmvc-kuang-jia-ji-chu/Documents/Desktop/GuiGu/Springboot2/笔记/img/img002.png"></p><h3 id="2、转发视图"><a href="#2、转发视图" class="headerlink" title="2、转发视图"></a>2、转发视图</h3><p>SpringMVC中默认的转发视图是InternalResourceView</p><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转</p><p>例如”forward:/“，”forward:/employee”</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testForward")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testForward</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"forward:/testHello"</span>;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="/2022/05/17/springmvc-kuang-jia-ji-chu/Documents/Desktop/GuiGu/Springboot2/笔记/img/img003.png" alt="image-20210706201316593"></p><h3 id="3、重定向视图"><a href="#3、重定向视图" class="headerlink" title="3、重定向视图"></a>3、重定向视图</h3><p>SpringMVC中默认的重定向视图是RedirectView</p><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p><p>例如”redirect:/“，”redirect:/employee”</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testRedirect")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRedirect</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/testHello"</span>;}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="/2022/05/17/springmvc-kuang-jia-ji-chu/Documents/Desktop/GuiGu/Springboot2/笔记/img/img004.png" alt="image-20210706201602267"></p><blockquote><p>注：</p><p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p></blockquote><h3 id="4、视图控制器view-controller"><a href="#4、视图控制器view-controller" class="headerlink" title="4、视图控制器view-controller"></a>4、视图控制器view-controller</h3><p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">    path：设置处理的请求地址</span><span class="hljs-comment">    view-name：设置请求地址所对应的视图名称</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/testView"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"success"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span></code></pre><blockquote><p>注：</p><p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p><p>&lt;mvc:annotation-driven /&gt;</p></blockquote><h1 id="七、RESTful"><a href="#七、RESTful" class="headerlink" title="七、RESTful"></a>七、RESTful</h1><h3 id="1、RESTful简介"><a href="#1、RESTful简介" class="headerlink" title="1、RESTful简介"></a>1、RESTful简介</h3><p>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，表现层资源状态转移。</p><h5 id="a-gt-资源"><a href="#a-gt-资源" class="headerlink" title="a>资源"></a>a&gt;资源</h5><p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><h5 id="b-gt-资源的表述"><a href="#b-gt-资源的表述" class="headerlink" title="b>资源的表述"></a>b&gt;资源的表述</h5><p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><h5 id="c-gt-状态转移"><a href="#c-gt-状态转移" class="headerlink" title="c>状态转移"></a>c&gt;状态转移</h5><p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><h3 id="2、RESTful的实现"><a href="#2、RESTful的实现" class="headerlink" title="2、RESTful的实现"></a>2、RESTful的实现</h3><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p><p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p><p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id=1</td><td>user/1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id=1</td><td>user/1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table><h3 id="3、HiddenHttpMethodFilter"><a href="#3、HiddenHttpMethodFilter" class="headerlink" title="3、HiddenHttpMethodFilter"></a>3、HiddenHttpMethodFilter</h3><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><p>a&gt;当前请求的请求方式必须为post</p><p>b&gt;当前请求必须传输请求参数_method</p><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式</p><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong> </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span></code></pre><blockquote><p>注：</p><p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p></li><li><p>```<br>String paramValue = request.getParameter(this.methodParam);</p><pre><code class="hljs plaintext"># 八、RESTful案例### 1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。- 搭建环境- 准备实体类 ```java package com.atguigu.mvc.bean;  public class Employee {     private Integer id;    private String lastName;     private String email;    //1 male, 0 female    private Integer gender;        public Integer getId() {       return id;    }     public void setId(Integer id) {       this.id = id;    }     public String getLastName() {       return lastName;    }     public void setLastName(String lastName) {       this.lastName = lastName;    }     public String getEmail() {       return email;    }     public void setEmail(String email) {       this.email = email;    }     public Integer getGender() {       return gender;    }     public void setGender(Integer gender) {       this.gender = gender;    }     public Employee(Integer id, String lastName, String email, Integer gender) {       super();       this.id = id;       this.lastName = lastName;       this.email = email;       this.gender = gender;    }     public Employee() {    } }</code></pre></li></ul></blockquote><ul><li><p>准备dao模拟数据</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.mvc.dao;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> com.atguigu.mvc.bean.Employee;<span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<span class="hljs-meta">@Repository</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmployeeDao</span> {   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="hljs-literal">null</span>;      <span class="hljs-keyword">static</span>{      employees = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Employee&gt;();      employees.put(<span class="hljs-number">1001</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1001</span>, <span class="hljs-string">"E-AA"</span>, <span class="hljs-string">"aa@163.com"</span>, <span class="hljs-number">1</span>));      employees.put(<span class="hljs-number">1002</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1002</span>, <span class="hljs-string">"E-BB"</span>, <span class="hljs-string">"bb@163.com"</span>, <span class="hljs-number">1</span>));      employees.put(<span class="hljs-number">1003</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1003</span>, <span class="hljs-string">"E-CC"</span>, <span class="hljs-string">"cc@163.com"</span>, <span class="hljs-number">0</span>));      employees.put(<span class="hljs-number">1004</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1004</span>, <span class="hljs-string">"E-DD"</span>, <span class="hljs-string">"dd@163.com"</span>, <span class="hljs-number">0</span>));      employees.put(<span class="hljs-number">1005</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-number">1005</span>, <span class="hljs-string">"E-EE"</span>, <span class="hljs-string">"ee@163.com"</span>, <span class="hljs-number">1</span>));   }      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">initId</span> <span class="hljs-operator">=</span> <span class="hljs-number">1006</span>;      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Employee employee)</span>{      <span class="hljs-keyword">if</span>(employee.getId() == <span class="hljs-literal">null</span>){         employee.setId(initId++);      }      employees.put(employee.getId(), employee);   }      <span class="hljs-keyword">public</span> Collection&lt;Employee&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>{      <span class="hljs-keyword">return</span> employees.values();   }      <span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">get</span><span class="hljs-params">(Integer id)</span>{      <span class="hljs-keyword">return</span> employees.get(id);   }      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>{      employees.remove(id);   }}</code></pre></li></ul><h3 id="2、功能清单"><a href="#2、功能清单" class="headerlink" title="2、功能清单"></a>2、功能清单</h3><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页√</td><td>/</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>/employee</td><td>GET</td></tr><tr><td>删除√</td><td>/employee/2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>/toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>/employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>/employee/2</td><td>GET</td></tr><tr><td>执行更新√</td><td>/employee</td><td>PUT</td></tr></tbody></table><h3 id="3、具体功能：访问首页"><a href="#3、具体功能：访问首页" class="headerlink" title="3、具体功能：访问首页"></a>3、具体功能：访问首页</h3><h5 id="a-gt-配置view-controller"><a href="#a-gt-配置view-controller" class="headerlink" title="a>配置view-controller"></a>a&gt;配置view-controller</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"index"</span>/&gt;</span></code></pre><h5 id="b-gt-创建页面"><a href="#b-gt-创建页面" class="headerlink" title="b>创建页面"></a>b&gt;创建页面</h5><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/employee}"</span>&gt;</span>访问员工信息<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="4、具体功能：查询所有员工数据"><a href="#4、具体功能：查询所有员工数据" class="headerlink" title="4、具体功能：查询所有员工数据"></a>4、具体功能：查询所有员工数据</h3><h5 id="a-gt-控制器方法"><a href="#a-gt-控制器方法" class="headerlink" title="a>控制器方法"></a>a&gt;控制器方法</h5><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/employee", method = RequestMethod.GET)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmployeeList</span><span class="hljs-params">(Model model)</span>{    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();    model.addAttribute(<span class="hljs-string">"employeeList"</span>, employeeList);    <span class="hljs-keyword">return</span> <span class="hljs-string">"employee_list"</span>;}</code></pre><h5 id="b-gt-创建employee-list-html"><a href="#b-gt-创建employee-list-html" class="headerlink" title="b>创建employee_list.html"></a>b&gt;创建employee_list.html</h5><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Employee Info<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/static/js/vue.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">cellpadding</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"text-align: center;"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dataTable"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"5"</span>&gt;</span>Employee Info<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>id<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>lastName<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>email<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>gender<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>options(<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/toAdd}"</span>&gt;</span>add<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>)<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"employee : ${employeeList}"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${employee.id}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${employee.lastName}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${employee.email}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"${employee.gender}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"deleteA"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deleteEmployee"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{'/employee/'+${employee.id}}"</span>&gt;</span>delete<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{'/employee/'+${employee.id}}"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="5、具体功能：删除"><a href="#5、具体功能：删除" class="headerlink" title="5、具体功能：删除"></a>5、具体功能：删除</h3><h5 id="a-gt-创建处理delete请求方式的表单"><a href="#a-gt-创建处理delete请求方式的表单" class="headerlink" title="a>创建处理delete请求方式的表单"></a>a&gt;创建处理delete请求方式的表单</h5><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"delete_form"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_method"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"delete"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><h5 id="b-gt-删除超链接绑定点击事件"><a href="#b-gt-删除超链接绑定点击事件" class="headerlink" title="b>删除超链接绑定点击事件"></a>b&gt;删除超链接绑定点击事件</h5><p>引入vue.js</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/static/js/vue.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>删除超链接</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"deleteA"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"deleteEmployee"</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{'/employee/'+${employee.id}}"</span>&gt;</span>delete<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>通过vue处理点击事件</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">var</span> vue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({</span><span class="language-javascript">        <span class="hljs-attr">el</span>:<span class="hljs-string">"#dataTable"</span>,</span><span class="language-javascript">        <span class="hljs-attr">methods</span>:{</span><span class="language-javascript">            <span class="hljs-comment">//event表示当前事件</span></span><span class="language-javascript">            <span class="hljs-attr">deleteEmployee</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {</span><span class="language-javascript">                <span class="hljs-comment">//通过id获取表单标签</span></span><span class="language-javascript">                <span class="hljs-keyword">var</span> delete_form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"delete_form"</span>);</span><span class="language-javascript">                <span class="hljs-comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span><span class="language-javascript">                delete_form.<span class="hljs-property">action</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">href</span>;</span><span class="language-javascript">                <span class="hljs-comment">//提交表单</span></span><span class="language-javascript">                delete_form.<span class="hljs-title function_">submit</span>();</span><span class="language-javascript">                <span class="hljs-comment">//阻止超链接的默认跳转行为</span></span><span class="language-javascript">                event.<span class="hljs-title function_">preventDefault</span>();</span><span class="language-javascript">            }</span><span class="language-javascript">        }</span><span class="language-javascript">    });</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h5 id="c-gt-控制器方法"><a href="#c-gt-控制器方法" class="headerlink" title="c>控制器方法"></a>c&gt;控制器方法</h5><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/employee/{id}", method = RequestMethod.DELETE)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">deleteEmployee</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Integer id)</span>{    employeeDao.delete(id);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/employee"</span>;}</code></pre><h3 id="6、具体功能：跳转到添加数据页面"><a href="#6、具体功能：跳转到添加数据页面" class="headerlink" title="6、具体功能：跳转到添加数据页面"></a>6、具体功能：跳转到添加数据页面</h3><h5 id="a-gt-配置view-controller-1"><a href="#a-gt-配置view-controller-1" class="headerlink" title="a>配置view-controller"></a>a&gt;配置view-controller</h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/toAdd"</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">"employee_add"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-controller</span>&gt;</span></code></pre><h5 id="b-gt-创建employee-add-html"><a href="#b-gt-创建employee-add-html" class="headerlink" title="b>创建employee_add.html"></a>b&gt;创建employee_add.html</h5><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Add Employee<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/employee}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    lastName:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    email:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    gender:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>&gt;</span>male    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span>&gt;</span>female<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"add"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="7、具体功能：执行保存"><a href="#7、具体功能：执行保存" class="headerlink" title="7、具体功能：执行保存"></a>7、具体功能：执行保存</h3><h5 id="a-gt-控制器方法-1"><a href="#a-gt-控制器方法-1" class="headerlink" title="a>控制器方法"></a>a&gt;控制器方法</h5><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/employee", method = RequestMethod.POST)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">addEmployee</span><span class="hljs-params">(Employee employee)</span>{    employeeDao.save(employee);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/employee"</span>;}</code></pre><h3 id="8、具体功能：跳转到更新数据页面"><a href="#8、具体功能：跳转到更新数据页面" class="headerlink" title="8、具体功能：跳转到更新数据页面"></a>8、具体功能：跳转到更新数据页面</h3><h5 id="a-gt-修改超链接"><a href="#a-gt-修改超链接" class="headerlink" title="a>修改超链接"></a>a&gt;修改超链接</h5><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{'/employee/'+${employee.id}}"</span>&gt;</span>update<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><h5 id="b-gt-控制器方法"><a href="#b-gt-控制器方法" class="headerlink" title="b>控制器方法"></a>b&gt;控制器方法</h5><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/employee/{id}", method = RequestMethod.GET)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEmployeeById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable("id")</span> Integer id, Model model)</span>{    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeDao.get(id);    model.addAttribute(<span class="hljs-string">"employee"</span>, employee);    <span class="hljs-keyword">return</span> <span class="hljs-string">"employee_update"</span>;}</code></pre><h5 id="c-gt-创建employee-update-html"><a href="#c-gt-创建employee-update-html" class="headerlink" title="c>创建employee_update.html"></a>c&gt;创建employee_update.html</h5><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Update Employee<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/employee}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"_method"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"put"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"hidden"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"${employee.id}"</span>&gt;</span>    lastName:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"lastName"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"${employee.lastName}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    email:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span> <span class="hljs-attr">th:value</span>=<span class="hljs-string">"${employee.email}"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        th:field="${employee.gender}"可用于单选框或复选框的回显</span><span class="hljs-comment">        若单选框的value和employee.gender的值一致，则添加checked="checked"属性</span><span class="hljs-comment">    --&gt;</span>    gender:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">th:field</span>=<span class="hljs-string">"${employee.gender}"</span>&gt;</span>male    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gender"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">th:field</span>=<span class="hljs-string">"${employee.gender}"</span>&gt;</span>female<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"update"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h3 id="9、具体功能：执行更新"><a href="#9、具体功能：执行更新" class="headerlink" title="9、具体功能：执行更新"></a>9、具体功能：执行更新</h3><h5 id="a-gt-控制器方法-2"><a href="#a-gt-控制器方法-2" class="headerlink" title="a>控制器方法"></a>a&gt;控制器方法</h5><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = "/employee", method = RequestMethod.PUT)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateEmployee</span><span class="hljs-params">(Employee employee)</span>{    employeeDao.save(employee);    <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/employee"</span>;}</code></pre><h1 id="八、HttpMessageConverter"><a href="#八、HttpMessageConverter" class="headerlink" title="八、HttpMessageConverter"></a>八、HttpMessageConverter</h1><p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p><p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，</p><p>ResponseEntity</p><h3 id="1、-RequestBody（常用）"><a href="#1、-RequestBody（常用）" class="headerlink" title="1、@RequestBody（常用）"></a>1、@RequestBody（常用）</h3><p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">"@{/testRequestBody}"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    用户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testRequestBody")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestBody</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String requestBody)</span>{    System.out.println(<span class="hljs-string">"requestBody:"</span>+requestBody);    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><p>输出结果：</p><p>requestBody:username=admin&amp;password=123456</p><h3 id="2、RequestEntity"><a href="#2、RequestEntity" class="headerlink" title="2、RequestEntity"></a>2、RequestEntity</h3><p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testRequestEntity")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testRequestEntity</span><span class="hljs-params">(RequestEntity&lt;String&gt; requestEntity)</span>{    System.out.println(<span class="hljs-string">"requestHeader:"</span>+requestEntity.getHeaders());    System.out.println(<span class="hljs-string">"requestBody:"</span>+requestEntity.getBody());    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><p>输出结果：<br>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080"</a>, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]<br>requestBody:username=admin&amp;password=123</p><h3 id="3、-ResponseBody"><a href="#3、-ResponseBody" class="headerlink" title="3、@ResponseBody"></a>3、@ResponseBody</h3><p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testResponseBody")</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testResponseBody</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;}</code></pre><p>结果：浏览器页面显示success</p><h3 id="4、SpringMVC处理json"><a href="#4、SpringMVC处理json" class="headerlink" title="4、SpringMVC处理json"></a>4、SpringMVC处理json</h3><p>@ResponseBody处理json的步骤：</p><p>a&gt;导入jackson的依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p><pre><code class="hljs plaintext">&lt;mvc:annotation-driven /&gt;</code></pre><p>c&gt;在处理器方法上使用@ResponseBody注解进行标识</p><p>d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testResponseUser")</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> User <span class="hljs-title function_">testResponseUser</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1001</span>,<span class="hljs-string">"admin"</span>,<span class="hljs-string">"123456"</span>,<span class="hljs-number">23</span>,<span class="hljs-string">"男"</span>);}</code></pre><p>浏览器的页面中展示的结果：</p><p>{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p><h3 id="5、SpringMVC处理ajax"><a href="#5、SpringMVC处理ajax" class="headerlink" title="5、SpringMVC处理ajax"></a>5、SpringMVC处理ajax</h3><p>a&gt;请求超链接：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">th:href</span>=<span class="hljs-string">"@{/testAjax}"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"testAjax"</span>&gt;</span>testAjax<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>b&gt;通过jQuery和ajax处理点击事件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">th:src</span>=<span class="hljs-string">"@{/static/js/jquery-1.7.2.js}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    $(<span class="hljs-string">"#testAxios"</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">"click"</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>){</span><span class="language-javascript">        $.<span class="hljs-title function_">ajax</span>({</span><span class="language-javascript">            <span class="hljs-comment">/*传输类型*/</span></span><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-string">"POST"</span>,</span><span class="language-javascript">            <span class="hljs-attr">url</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">href</span>,</span><span class="language-javascript">            <span class="hljs-comment">/*默认为异步传输，Flase为同步传输*/</span></span><span class="language-javascript">            <span class="hljs-attr">async</span>:<span class="hljs-literal">false</span>,</span><span class="language-javascript">            <span class="hljs-comment">/*发送信息至服务器时内容编码类型*/</span></span><span class="language-javascript">            <span class="hljs-attr">contentType</span>: <span class="hljs-string">"application/json"</span>,</span><span class="language-javascript">            <span class="hljs-comment">/*传到服务器的数据*/</span></span><span class="language-javascript">            <span class="hljs-attr">data</span>:<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({username : <span class="hljs-string">"admin"</span>,<span class="hljs-attr">password</span>:<span class="hljs-string">"123456"</span>}),</span><span class="language-javascript">            <span class="hljs-comment">/*返回值类型*/</span></span><span class="language-javascript">            <span class="hljs-attr">dataType</span>:<span class="hljs-string">"text"</span>,</span><span class="language-javascript">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) {</span><span class="language-javascript">                <span class="hljs-title function_">alert</span>(res)</span><span class="language-javascript">            },</span><span class="language-javascript">            <span class="hljs-attr">error</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>){</span><span class="language-javascript">                <span class="hljs-title function_">alert</span>(<span class="hljs-string">"error!!!"</span>)</span><span class="language-javascript">            }</span><span class="language-javascript">        })</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span></span><span class="language-javascript">    })</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>c&gt;控制器方法：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/testAxios")</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testAxios</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String msg)</span>{    System.out.println(msg);    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello,axios"</span>;}</code></pre><h3 id="6、-RestController注解"><a href="#6、-RestController注解" class="headerlink" title="6、@RestController注解"></a>6、@RestController注解</h3><p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p><h3 id="7、ResponseEntity"><a href="#7、ResponseEntity" class="headerlink" title="7、ResponseEntity"></a>7、ResponseEntity</h3><p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p><h1 id="九、文件上传和下载"><a href="#九、文件上传和下载" class="headerlink" title="九、文件上传和下载"></a>九、文件上传和下载</h1><h3 id="1、文件下载"><a href="#1、文件下载" class="headerlink" title="1、文件下载"></a>1、文件下载</h3><p>使用ResponseEntity实现下载文件的功能</p><pre><code class="hljs java"><span class="hljs-comment">/*下载*/</span>    <span class="hljs-meta">@RequestMapping("/testDown")</span>    <span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="hljs-keyword">throws</span> IOException {        <span class="hljs-comment">//获取ServletContext对象</span>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();        <span class="hljs-comment">//获取服务器中文件的真实路径</span>        <span class="hljs-comment">//形参为在servletContext真实路径上加上虚拟地址“/static/img/1.jpg”</span>        <span class="hljs-comment">//字符串realPath = 真实路径 + "/static/img/1.jpg"</span>        <span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">"/static/img/1.jpg"</span>);        System.out.println(realPath);        <span class="hljs-comment">//创建输入流</span>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);        <span class="hljs-comment">//创建字节数组 |  is.available()：获取当前文件所有的字节</span>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[is.available()];        <span class="hljs-comment">//将流读到字节数组中</span>        is.read(bytes);        <span class="hljs-comment">//创建HttpHeaders对象设置响应头信息</span>        MultiValueMap&lt;String, String&gt; headers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();        <span class="hljs-comment">//设置要下载方式以及下载文件的名字</span>        <span class="hljs-comment">/*key：Content-Disposition | value：attachment;filename=1.jpg：附件下载方式*/</span>        headers.add(<span class="hljs-string">"Content-Disposition"</span>, <span class="hljs-string">"attachment;filename=1.jpg"</span>);        <span class="hljs-comment">//设置响应状态码 OK：200</span>        <span class="hljs-type">HttpStatus</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> HttpStatus.OK;        <span class="hljs-comment">//创建ResponseEntity对象</span>        ResponseEntity&lt;<span class="hljs-type">byte</span>[]&gt; responseEntity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-type">byte</span>[]&gt;(bytes, headers, statusCode);        <span class="hljs-comment">//关闭输入流</span>        is.close();        <span class="hljs-keyword">return</span> responseEntity;    }</code></pre><h3 id="2、文件上传"><a href="#2、文件上传" class="headerlink" title="2、文件上传"></a>2、文件上传</h3><p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data”</p><p>SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p><p>上传步骤：</p><p>a&gt;添加依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>b&gt;在SpringMVC的配置文件中添加配置：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"multipartResolver"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>c&gt;控制器方法：</p><pre><code class="hljs java">    <span class="hljs-comment">/*上传*/</span>    <span class="hljs-meta">@RequestMapping("/testUp")</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testUp</span><span class="hljs-params">(MultipartFile photo, HttpSession session)</span> <span class="hljs-keyword">throws</span> IOException {        <span class="hljs-comment">//获取上传的文件的文件名</span>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> photo.getOriginalFilename();        <span class="hljs-comment">//获取上传的文件的后缀名</span>        <span class="hljs-type">String</span> <span class="hljs-variable">suffixName</span> <span class="hljs-operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="hljs-string">"."</span>));        <span class="hljs-comment">//将UUID作为文件名</span>        <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>);        <span class="hljs-comment">//将uuid和后缀名拼接后的结果作为最终的文件名</span>        fileName = uuid + suffixName;        <span class="hljs-comment">//通过ServletContext获取服务器中photo目录的路径</span>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> session.getServletContext();        <span class="hljs-type">String</span> <span class="hljs-variable">photoPath</span> <span class="hljs-operator">=</span> servletContext.getRealPath(<span class="hljs-string">"photo"</span>);<span class="hljs-comment">//        System.out.println(photoPath);</span>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(photoPath);        <span class="hljs-comment">//判断photoPath所对应路径是否存在</span>        <span class="hljs-keyword">if</span>(!file.exists()){            <span class="hljs-comment">//若不存在，则创建目录</span>            file.mkdir();        }        <span class="hljs-comment">//File.separator：文件分隔符</span>        <span class="hljs-type">String</span> <span class="hljs-variable">finalPath</span> <span class="hljs-operator">=</span> photoPath + File.separator + fileName;        <span class="hljs-comment">//上传文件 将客户端的文件位置转移到服务器路径</span>        photo.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(finalPath));        <span class="hljs-keyword">return</span> <span class="hljs-string">"success"</span>;    }</code></pre><h1 id="十、拦截器"><a href="#十、拦截器" class="headerlink" title="十、拦截器"></a>十、拦截器</h1><h3 id="1、拦截器的配置"><a href="#1、拦截器的配置" class="headerlink" title="1、拦截器的配置"></a>1、拦截器的配置</h3><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置拦截器--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span>        <span class="hljs-comment">&lt;!--①拦截器配置 配置到对应的bean中--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"firstInterceptor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"secondInterceptor"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ref</span>&gt;</span>        <span class="hljs-comment">&lt;!--②--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;bean class="com.atguigu.mvc.interceptors.FirstInterceptor"&gt;&lt;/bean&gt;--&gt;</span>        <span class="hljs-comment">&lt;!--&lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;--&gt;</span>        <span class="hljs-comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span>        <span class="hljs-comment">&lt;!--③高级配置拦截器 | 指定拦截规则--&gt;</span>        <span class="hljs-comment">&lt;!--/*：表示上下文路径 | /**：表示所有路径--&gt;</span>        <span class="hljs-comment">&lt;!-- 这种配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求--&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">            &lt;mvc:interceptor&gt;</span><span class="hljs-comment">                &lt;mvc:mapping path="/**"/&gt;</span><span class="hljs-comment">                &lt;mvc:exclude-mapping path="/"/&gt;</span><span class="hljs-comment">                &lt;ref bean="firstInterceptor"&gt;&lt;/ref&gt;</span><span class="hljs-comment">            &lt;/mvc:interceptor&gt;</span><span class="hljs-comment">        --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre><h3 id="2、拦截器的三个抽象方法"><a href="#2、拦截器的三个抽象方法" class="headerlink" title="2、拦截器的三个抽象方法"></a>2、拦截器的三个抽象方法</h3><p>SpringMVC中的拦截器有三个抽象方法：</p><p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p><p>postHandle：控制器方法执行之后执行postHandle()</p><p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p><h3 id="3、多个拦截器的执行顺序"><a href="#3、多个拦截器的执行顺序" class="headerlink" title="3、多个拦截器的执行顺序"></a>3、多个拦截器的执行顺序</h3><p>a&gt;若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p><p>b&gt;若某个拦截器的preHandle()返回了false</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p><h1 id="十一、异常处理器"><a href="#十一、异常处理器" class="headerlink" title="十一、异常处理器"></a>十一、异常处理器</h1><h3 id="1、基于配置的异常处理"><a href="#1、基于配置的异常处理" class="headerlink" title="1、基于配置的异常处理"></a>1、基于配置的异常处理</h3><p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p><p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</p><p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exceptionMappings"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span>            <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">                properties的键表示处理器方法执行过程中出现的异常</span><span class="hljs-comment">                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span><span class="hljs-comment">            --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"java.lang.ArithmeticException"</span>&gt;</span>error<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span><span class="hljs-comment">    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"exceptionAttribute"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ex"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h3 id="2、基于注解的异常处理"><a href="#2、基于注解的异常处理" class="headerlink" title="2、基于注解的异常处理"></a>2、基于注解的异常处理</h3><pre><code class="hljs java"><span class="hljs-comment">//@ControllerAdvice将当前类标识为异常处理的组件</span><span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionController</span> {    <span class="hljs-comment">//@ExceptionHandler用于设置所标识方法处理的异常</span>    <span class="hljs-meta">@ExceptionHandler(ArithmeticException.class)</span>    <span class="hljs-comment">//ex表示当前请求处理中出现的异常对象</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleArithmeticException</span><span class="hljs-params">(Exception ex, Model model)</span>{        model.addAttribute(<span class="hljs-string">"ex"</span>, ex);        <span class="hljs-keyword">return</span> <span class="hljs-string">"error"</span>;    }}</code></pre><h1 id="十二、注解配置SpringMVC"><a href="#十二、注解配置SpringMVC" class="headerlink" title="十二、注解配置SpringMVC"></a>十二、注解配置SpringMVC</h1><p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p><h3 id="1、创建初始化类，代替web-xml"><a href="#1、创建初始化类，代替web-xml" class="headerlink" title="1、创建初始化类，代替web.xml"></a>1、创建初始化类，代替web.xml</h3><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。<br>Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> {    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指定spring的配置类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{SpringConfig.class};    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指定SpringMVC的配置类</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]{WebConfig.class};    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> String[] getServletMappings() {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{<span class="hljs-string">"/"</span>};    }    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 添加过滤器</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> Filter[] getServletFilters() {        <span class="hljs-type">CharacterEncodingFilter</span> <span class="hljs-variable">encodingFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharacterEncodingFilter</span>();        encodingFilter.setEncoding(<span class="hljs-string">"UTF-8"</span>);        encodingFilter.setForceRequestEncoding(<span class="hljs-literal">true</span>);        <span class="hljs-type">HiddenHttpMethodFilter</span> <span class="hljs-variable">hiddenHttpMethodFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HiddenHttpMethodFilter</span>();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>[]{encodingFilter, hiddenHttpMethodFilter};    }}</code></pre><h3 id="2、创建SpringConfig配置类，代替spring的配置文件"><a href="#2、创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="2、创建SpringConfig配置类，代替spring的配置文件"></a>2、创建SpringConfig配置类，代替spring的配置文件</h3><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringConfig</span> {    <span class="hljs-comment">//ssm整合之后，spring的配置信息写在此类中</span>}</code></pre><h3 id="3、创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#3、创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="3、创建WebConfig配置类，代替SpringMVC的配置文件"></a>3、创建WebConfig配置类，代替SpringMVC的配置文件</h3><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Date:2021/7/10</span><span class="hljs-comment"> * Author:ybc</span><span class="hljs-comment"> * Description:相当于SpringMVC.xml</span><span class="hljs-comment"> */</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 代替SpringMVC的配置文件：</span><span class="hljs-comment"> * 1、扫描组件   2、视图解析器     3、view-controller（视图管理）    4、default-servlet-handler</span><span class="hljs-comment"> * 5、mvc注解驱动    6、文件上传解析器   7、异常处理      8、拦截器</span><span class="hljs-comment"> */</span><span class="hljs-comment">//将当前类标识为一个配置类</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//1、扫描组件</span><span class="hljs-meta">@ComponentScan("com.atguigu.mvc.controller")</span><span class="hljs-comment">//5、mvc注解驱动</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {    <span class="hljs-comment">//4、default-servlet-handler</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureDefaultServletHandling</span><span class="hljs-params">(DefaultServletHandlerConfigurer configurer)</span> {        configurer.enable();    }    <span class="hljs-comment">//8、拦截器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> {        <span class="hljs-type">TestInterceptor</span> <span class="hljs-variable">testInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestInterceptor</span>();        registry.addInterceptor(testInterceptor).addPathPatterns(<span class="hljs-string">"/**"</span>);    }    <span class="hljs-comment">//3、view-controller 视图管理器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> {        registry.addViewController(<span class="hljs-string">"/hello"</span>).setViewName(<span class="hljs-string">"hello"</span>);    }    <span class="hljs-comment">//6、文件上传解析器</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title function_">multipartResolver</span><span class="hljs-params">()</span>{        <span class="hljs-type">CommonsMultipartResolver</span> <span class="hljs-variable">commonsMultipartResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonsMultipartResolver</span>();        <span class="hljs-keyword">return</span> commonsMultipartResolver;    }    <span class="hljs-comment">//7、异常处理</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureHandlerExceptionResolvers</span><span class="hljs-params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> {        <span class="hljs-type">SimpleMappingExceptionResolver</span> <span class="hljs-variable">exceptionResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleMappingExceptionResolver</span>();        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        prop.setProperty(<span class="hljs-string">"java.lang.ArithmeticException"</span>, <span class="hljs-string">"error"</span>);        exceptionResolver.setExceptionMappings(prop);        exceptionResolver.setExceptionAttribute(<span class="hljs-string">"exception"</span>);        resolvers.add(exceptionResolver);    }    <span class="hljs-comment">//配置生成模板解析器</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> ITemplateResolver <span class="hljs-title function_">templateResolver</span><span class="hljs-params">()</span> {        <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">webApplicationContext</span> <span class="hljs-operator">=</span> ContextLoader.getCurrentWebApplicationContext();        <span class="hljs-comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span>        <span class="hljs-type">ServletContextTemplateResolver</span> <span class="hljs-variable">templateResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextTemplateResolver</span>(                webApplicationContext.getServletContext());        templateResolver.setPrefix(<span class="hljs-string">"/WEB-INF/templates/"</span>);        templateResolver.setSuffix(<span class="hljs-string">".html"</span>);        templateResolver.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);        templateResolver.setTemplateMode(TemplateMode.HTML);        <span class="hljs-keyword">return</span> templateResolver;    }    <span class="hljs-comment">//生成模板引擎并为模板引擎注入模板解析器</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> SpringTemplateEngine <span class="hljs-title function_">templateEngine</span><span class="hljs-params">(ITemplateResolver templateResolver)</span> {        <span class="hljs-type">SpringTemplateEngine</span> <span class="hljs-variable">templateEngine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringTemplateEngine</span>();        templateEngine.setTemplateResolver(templateResolver);        <span class="hljs-keyword">return</span> templateEngine;    }    <span class="hljs-comment">//生成视图解析器并未解析器注入模板引擎</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> ViewResolver <span class="hljs-title function_">viewResolver</span><span class="hljs-params">(SpringTemplateEngine templateEngine)</span> {        <span class="hljs-type">ThymeleafViewResolver</span> <span class="hljs-variable">viewResolver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThymeleafViewResolver</span>();        viewResolver.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);        viewResolver.setTemplateEngine(templateEngine);        <span class="hljs-keyword">return</span> viewResolver;    }}</code></pre><h3 id="4、测试功能"><a href="#4、测试功能" class="headerlink" title="4、测试功能"></a>4、测试功能</h3><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping("/")</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">index</span><span class="hljs-params">()</span>{    <span class="hljs-keyword">return</span> <span class="hljs-string">"index"</span>;}</code></pre><h1 id="十三、SpringMVC执行流程"><a href="#十三、SpringMVC执行流程" class="headerlink" title="十三、SpringMVC执行流程"></a>十三、SpringMVC执行流程</h1><h3 id="1、SpringMVC常用组件"><a href="#1、SpringMVC常用组件" class="headerlink" title="1、SpringMVC常用组件"></a>1、SpringMVC常用组件</h3><ul><li>DispatcherServlet：<strong>前端控制器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p><ul><li>HandlerMapping：<strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p><ul><li>Handler：<strong>处理器</strong>，需要工程师开发</li></ul><p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p><ul><li>HandlerAdapter：<strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p><ul><li>ViewResolver：<strong>视图解析器</strong>，不需要工程师开发，由框架提供</li></ul><p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView</p><ul><li>View：<strong>视图</strong></li></ul><p>作用：将模型数据通过页面展示给用户</p><h3 id="2、DispatcherServlet初始化过程"><a href="#2、DispatcherServlet初始化过程" class="headerlink" title="2、DispatcherServlet初始化过程"></a>2、DispatcherServlet初始化过程</h3><p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="/2022/05/17/springmvc-kuang-jia-ji-chu/Documents/Desktop/GuiGu/Springboot2/笔记/img/img005.png" alt="images"></p><h5 id="a-gt-初始化WebApplicationContext"><a href="#a-gt-初始化WebApplicationContext" class="headerlink" title="a>初始化WebApplicationContext"></a>a&gt;初始化WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span><span class="hljs-params">()</span> {    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span>        WebApplicationContextUtils.getWebApplicationContext(getServletContext());    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webApplicationContext != <span class="hljs-literal">null</span>) {        <span class="hljs-comment">// A context instance was injected at construction time -&gt; use it</span>        wac = <span class="hljs-built_in">this</span>.webApplicationContext;        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) {            <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">cwac</span> <span class="hljs-operator">=</span> (ConfigurableWebApplicationContext) wac;            <span class="hljs-keyword">if</span> (!cwac.isActive()) {                <span class="hljs-comment">// The context has not yet been refreshed -&gt; provide services such as</span>                <span class="hljs-comment">// setting the parent context, setting the application context id, etc</span>                <span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-literal">null</span>) {                    <span class="hljs-comment">// The context instance was injected without an explicit parent -&gt; set</span>                    <span class="hljs-comment">// the root application context (if any; may be null) as the parent</span>                    cwac.setParent(rootContext);                }                configureAndRefreshWebApplicationContext(cwac);            }        }    }    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) {        <span class="hljs-comment">// No context instance was injected at construction time -&gt; see if one</span>        <span class="hljs-comment">// has been registered in the servlet context. If one exists, it is assumed</span>        <span class="hljs-comment">// that the parent context (if any) has already been set and that the</span>        <span class="hljs-comment">// user has performed any initialization such as setting the context id</span>        wac = findWebApplicationContext();    }    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) {        <span class="hljs-comment">// No context instance is defined for this servlet -&gt; create a local one</span>        <span class="hljs-comment">// 创建WebApplicationContext</span>        wac = createWebApplicationContext(rootContext);    }    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.refreshEventReceived) {        <span class="hljs-comment">// Either the context is not a ConfigurableApplicationContext with refresh</span>        <span class="hljs-comment">// support or the context injected at construction time had already been</span>        <span class="hljs-comment">// refreshed -&gt; trigger initial onRefresh manually here.</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.onRefreshMonitor) {            <span class="hljs-comment">// 刷新WebApplicationContext</span>            onRefresh(wac);        }    }    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.publishContext) {        <span class="hljs-comment">// Publish the context as a servlet context attribute.</span>        <span class="hljs-comment">// 将IOC容器在应用域共享</span>        <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> getServletContextAttributeName();        getServletContext().setAttribute(attrName, wac);    }    <span class="hljs-keyword">return</span> wac;}</code></pre><h5 id="b-gt-创建WebApplicationContext"><a href="#b-gt-创建WebApplicationContext" class="headerlink" title="b>创建WebApplicationContext"></a>b&gt;创建WebApplicationContext</h5><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createWebApplicationContext</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> ApplicationContext parent)</span> {    Class&lt;?&gt; contextClass = getContextClass();    <span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(            <span class="hljs-string">"Fatal initialization error in servlet with name '"</span> + getServletName() +            <span class="hljs-string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +            <span class="hljs-string">"] is not of type ConfigurableWebApplicationContext"</span>);    }    <span class="hljs-comment">// 通过反射创建 IOC 容器对象</span>    <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span>        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);    wac.setEnvironment(getEnvironment());    <span class="hljs-comment">// 设置父容器</span>    wac.setParent(parent);    <span class="hljs-type">String</span> <span class="hljs-variable">configLocation</span> <span class="hljs-operator">=</span> getContextConfigLocation();    <span class="hljs-keyword">if</span> (configLocation != <span class="hljs-literal">null</span>) {        wac.setConfigLocation(configLocation);    }    configureAndRefreshWebApplicationContext(wac);    <span class="hljs-keyword">return</span> wac;}</code></pre><h5 id="c-gt-DispatcherServlet初始化策略"><a href="#c-gt-DispatcherServlet初始化策略" class="headerlink" title="c>DispatcherServlet初始化策略"></a>c&gt;DispatcherServlet初始化策略</h5><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> {   initMultipartResolver(context);   initLocaleResolver(context);   initThemeResolver(context);   initHandlerMappings(context);   initHandlerAdapters(context);   initHandlerExceptionResolvers(context);   initRequestToViewNameTranslator(context);   initViewResolvers(context);   initFlashMapManager(context);}</code></pre><h3 id="3、DispatcherServlet调用组件处理请求"><a href="#3、DispatcherServlet调用组件处理请求" class="headerlink" title="3、DispatcherServlet调用组件处理请求"></a>3、DispatcherServlet调用组件处理请求</h3><h5 id="a-gt-processRequest"><a href="#a-gt-processRequest" class="headerlink" title="a>processRequest()"></a>a&gt;processRequest()</h5><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p><p>所在类：org.springframework.web.servlet.FrameworkServlet</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>    <span class="hljs-keyword">throws</span> ServletException, IOException {    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    <span class="hljs-type">Throwable</span> <span class="hljs-variable">failureCause</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">previousLocaleContext</span> <span class="hljs-operator">=</span> LocaleContextHolder.getLocaleContext();    <span class="hljs-type">LocaleContext</span> <span class="hljs-variable">localeContext</span> <span class="hljs-operator">=</span> buildLocaleContext(request);    <span class="hljs-type">RequestAttributes</span> <span class="hljs-variable">previousAttributes</span> <span class="hljs-operator">=</span> RequestContextHolder.getRequestAttributes();    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> buildRequestAttributes(request, response, previousAttributes);    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestBindingInterceptor</span>());    initContextHolders(request, localeContext, requestAttributes);    <span class="hljs-keyword">try</span> {        <span class="hljs-comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span>        doService(request, response);    }    <span class="hljs-keyword">catch</span> (ServletException | IOException ex) {        failureCause = ex;        <span class="hljs-keyword">throw</span> ex;    }    <span class="hljs-keyword">catch</span> (Throwable ex) {        failureCause = ex;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">"Request processing failed"</span>, ex);    }    <span class="hljs-keyword">finally</span> {        resetContextHolders(request, previousLocaleContext, previousAttributes);        <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-literal">null</span>) {            requestAttributes.requestCompleted();        }        logResult(request, response, failureCause, asyncManager);        publishRequestHandledEvent(request, response, startTime, failureCause);    }}</code></pre><h5 id="b-gt-doService"><a href="#b-gt-doService" class="headerlink" title="b>doService()"></a>b&gt;doService()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception {    logRequest(request);    <span class="hljs-comment">// Keep a snapshot of the request attributes in case of an include,</span>    <span class="hljs-comment">// to be able to restore the original attributes after the include.</span>    Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) {        attributesSnapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();        <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) {            <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> (String) attrNames.nextElement();            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {                attributesSnapshot.put(attrName, request.getAttribute(attrName));            }        }    }    <span class="hljs-comment">// Make framework objects available to handlers and view objects.</span>    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.localeResolver);    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-built_in">this</span>.themeResolver);    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.flashMapManager != <span class="hljs-literal">null</span>) {        <span class="hljs-type">FlashMap</span> <span class="hljs-variable">inputFlashMap</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);        <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-literal">null</span>) {            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));        }        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlashMap</span>());        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-built_in">this</span>.flashMapManager);    }    <span class="hljs-type">RequestPath</span> <span class="hljs-variable">requestPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) {        requestPath = ServletRequestPathUtils.parseAndCache(request);    }    <span class="hljs-keyword">try</span> {        <span class="hljs-comment">// 处理请求和响应</span>        doDispatch(request, response);    }    <span class="hljs-keyword">finally</span> {        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {            <span class="hljs-comment">// Restore the original attribute snapshot, in case of an include.</span>            <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-literal">null</span>) {                restoreAttributesAfterInclude(request, attributesSnapshot);            }        }        <span class="hljs-keyword">if</span> (requestPath != <span class="hljs-literal">null</span>) {            ServletRequestPathUtils.clearParsedRequestPath(request);        }    }}</code></pre><h5 id="c-gt-doDispatch"><a href="#c-gt-doDispatch" class="headerlink" title="c>doDispatch()"></a>c&gt;doDispatch()</h5><p>所在类：org.springframework.web.servlet.DispatcherServlet</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception {    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);    <span class="hljs-keyword">try</span> {        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> {            processedRequest = checkMultipart(request);            multipartRequestParsed = (processedRequest != request);            <span class="hljs-comment">// Determine handler for the current request.</span>            <span class="hljs-comment">/*</span><span class="hljs-comment">                mappedHandler：调用链</span><span class="hljs-comment">                包含handler、interceptorList、interceptorIndex</span><span class="hljs-comment">                handler：浏览器发送的请求所匹配的控制器方法</span><span class="hljs-comment">                interceptorList：处理控制器方法的所有拦截器集合</span><span class="hljs-comment">                interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span><span class="hljs-comment">            */</span>            mappedHandler = getHandler(processedRequest);            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) {                noHandlerFound(processedRequest, response);                <span class="hljs-keyword">return</span>;            }            <span class="hljs-comment">// Determine handler adapter for the current request.</span>               <span class="hljs-comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());            <span class="hljs-comment">// Process last-modified header, if supported by the handler.</span>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">"GET"</span>.equals(method);            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">"HEAD"</span>.equals(method)) {                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {                    <span class="hljs-keyword">return</span>;                }            }                        <span class="hljs-comment">// 调用拦截器的preHandle()</span>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) {                <span class="hljs-keyword">return</span>;            }            <span class="hljs-comment">// Actually invoke the handler.</span>            <span class="hljs-comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {                <span class="hljs-keyword">return</span>;            }            applyDefaultViewName(processedRequest, mv);            <span class="hljs-comment">// 调用拦截器的postHandle()</span>            mappedHandler.applyPostHandle(processedRequest, response, mv);        }        <span class="hljs-keyword">catch</span> (Exception ex) {            dispatchException = ex;        }        <span class="hljs-keyword">catch</span> (Throwable err) {            <span class="hljs-comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span>            <span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span>            dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">"Handler dispatch failed"</span>, err);        }        <span class="hljs-comment">// 后续处理：处理模型数据和渲染视图</span>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    }    <span class="hljs-keyword">catch</span> (Exception ex) {        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);    }    <span class="hljs-keyword">catch</span> (Throwable err) {        triggerAfterCompletion(processedRequest, response, mappedHandler,                               <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">"Handler processing failed"</span>, err));    }    <span class="hljs-keyword">finally</span> {        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) {            <span class="hljs-comment">// Instead of postHandle and afterCompletion</span>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) {                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            }        }        <span class="hljs-keyword">else</span> {            <span class="hljs-comment">// Clean up any resources used by a multipart request.</span>            <span class="hljs-keyword">if</span> (multipartRequestParsed) {                cleanupMultipart(processedRequest);            }        }    }}</code></pre><h5 id="d-gt-processDispatchResult"><a href="#d-gt-processDispatchResult" class="headerlink" title="d>processDispatchResult()"></a>d&gt;processDispatchResult()</h5><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="hljs-meta">@Nullable</span> ModelAndView mv,</span><span class="hljs-params">                                   <span class="hljs-meta">@Nullable</span> Exception exception)</span> <span class="hljs-keyword">throws</span> Exception {    <span class="hljs-type">boolean</span> <span class="hljs-variable">errorView</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) {        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) {            logger.debug(<span class="hljs-string">"ModelAndViewDefiningException encountered"</span>, exception);            mv = ((ModelAndViewDefiningException) exception).getModelAndView();        }        <span class="hljs-keyword">else</span> {            <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (mappedHandler != <span class="hljs-literal">null</span> ? mappedHandler.getHandler() : <span class="hljs-literal">null</span>);            mv = processHandlerException(request, response, handler, exception);            errorView = (mv != <span class="hljs-literal">null</span>);        }    }    <span class="hljs-comment">// Did the handler return a view to render?</span>    <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) {        <span class="hljs-comment">// 处理模型数据和渲染视图</span>        render(mv, request, response);        <span class="hljs-keyword">if</span> (errorView) {            WebUtils.clearErrorRequestAttributes(request);        }    }    <span class="hljs-keyword">else</span> {        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) {            logger.trace(<span class="hljs-string">"No view rendering, null ModelAndView returned."</span>);        }    }    <span class="hljs-keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {        <span class="hljs-comment">// Concurrent handling started during a forward</span>        <span class="hljs-keyword">return</span>;    }    <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) {        <span class="hljs-comment">// Exception (if any) is already handled..</span>        <span class="hljs-comment">// 调用拦截器的afterCompletion()</span>        mappedHandler.triggerAfterCompletion(request, response, <span class="hljs-literal">null</span>);    }}</code></pre><h3 id="4、SpringMVC的执行流程"><a href="#4、SpringMVC的执行流程" class="headerlink" title="4、SpringMVC的执行流程"></a>4、SpringMVC的执行流程</h3><ol><li><p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p></li></ol><p>a) 不存在</p><p>i. 再判断是否配置了mvc:default-servlet-handler</p><p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p>b) 存在则执行下面的流程</p><ol start="3"><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p></li><li><p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p></li></ol><p>a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p><p>b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p><p>c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p><p>d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p><ol start="7"><li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p></li><li><p>此时将开始执行拦截器的postHandle(…)方法【逆向】。</p></li><li><p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。</p></li><li><p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p></li><li><p>将渲染结果返回给客户端。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习教程</title>
      <link href="/2022/05/17/git-xue-xi-jiao-cheng/"/>
      <url>/2022/05/17/git-xue-xi-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="git.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新手健身笔记</title>
      <link href="/2022/05/12/xin-shou-jian-shen-bi-ji/"/>
      <url>/2022/05/12/xin-shou-jian-shen-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、饮食："><a href="#一、饮食：" class="headerlink" title="一、饮食："></a>一、饮食：</h1><ul><li>方便应以蛋白质为主，鱼肉蛋奶；</li><li>碳水和脂肪2选1，一起吃会变胖；</li><li>多吃叶子类的蔬菜获得膳食纤维和维生素，保证一个正常的消化节律和分泌系统，不能吃水果。</li><li>多喝水，便于同化蛋白质，不然对肾脏造成很大的负担。</li></ul><h1 id="二、减脂："><a href="#二、减脂：" class="headerlink" title="二、减脂："></a>二、减脂：</h1><ul><li>跑步需要20分钟之后才起到减脂作用</li><li>推荐慢跑，中低强度的有氧运动，保持稳定的心率，燃脂心率：125-154</li></ul><h1 id="三、增肌："><a href="#三、增肌：" class="headerlink" title="三、增肌："></a>三、增肌：</h1><h2 id="1、健身器材使用"><a href="#1、健身器材使用" class="headerlink" title="1、健身器材使用"></a>1、健身器材使用</h2><p>见知乎文章：<a href="https://www.zhihu.com/question/20425675/answer/460377967">健身房中各种器械的正确使用方法是怎样的？</a></p><ul><li>健身器材分为<strong>自由重量</strong>和<strong>固定器械</strong>。</li><li>新手小白建议直接练习固定器械。</li><li>自由重量有杠铃和哑铃，难以做到标准动作，可进阶。</li></ul><h2 id="2、新手训练计划"><a href="#2、新手训练计划" class="headerlink" title="2、新手训练计划"></a>2、新手训练计划</h2><ul><li>4组12-15次，组间休息时间90s-120s。</li><li>练习上肢动作时要收紧肩胛骨，步骤：耸肩-&gt;往后-&gt;下压</li><li>哑铃几乎可以训练到全身的肌肉，可以练胸、背、肩膀、手臂、腿</li></ul><h2 id="3、人体肌肉分布"><a href="#3、人体肌肉分布" class="headerlink" title="3、人体肌肉分布"></a>3、人体肌肉分布</h2><h3 id="正面"><a href="#正面" class="headerlink" title="正面"></a>正面</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/0D1B66C5019F93E6EB12D0757FD80CC5.jpg" alt="img"></p><h3 id="反面"><a href="#反面" class="headerlink" title="反面"></a>反面</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/CB4AB888CB3D91BE6D7CF57C41638BBB.jpg" alt="img"></p><h2 id="4、胸部训练"><a href="#4、胸部训练" class="headerlink" title="4、胸部训练"></a>4、胸部训练</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-4fb883bcfd7926c9c34ac76582359441_720w.jpg" alt="img"></p><h3 id="坐姿推胸（胸大肌，三角肌，肱三头肌）"><a href="#坐姿推胸（胸大肌，三角肌，肱三头肌）" class="headerlink" title="坐姿推胸（胸大肌，三角肌，肱三头肌）"></a>坐姿推胸（胸大肌，三角肌，肱三头肌）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-02a35b3aae249e0438f25ca9ebfd1cfd_720w.gif" alt="img"></p><p><em>使用方法：</em></p><p><strong>1.<strong>首先将器械的座椅调整到合适的高度，然后调整重量，坐到座椅上后，头部、上<a href="https://link.zhihu.com/?target=http://www.jianshen8.com/zhuanti/beibu.html">背部</a>紧贴到后面的靠背，腰部向前收紧。推起和还原时</strong>不要耸肩</strong>，保持肩部下沉</p><p><strong>2.<strong>眼睛平视，双手握紧握把，感觉胸部发力，将重量推起，同时呼气，推到顶点的时候肘关节</strong>不要完全伸直</strong>，还原，还原到两个大臂成一条直线的时候再次发力</p><p><em>注意事项：</em></p><p>有的人认为把推的动作做出来就算是一次有效动作，这是不对的，比推起来更重要的是慢放，控制肌肉，使其持续发力，直至回到起始位置才算一次有效动作。记住，当你放下器械时，听到较大的“哐哐哐”碰撞声，说明你的动作需要注意啦!</p><h3 id="哑铃推胸"><a href="#哑铃推胸" class="headerlink" title="哑铃推胸"></a>哑铃推胸</h3><h4 id="上斜仰卧哑铃卧推（胸大肌上部）"><a href="#上斜仰卧哑铃卧推（胸大肌上部）" class="headerlink" title="上斜仰卧哑铃卧推（胸大肌上部）"></a>上斜仰卧哑铃卧推（胸大肌上部）</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-f3d33cdccfb3c877a9bf3563821ae7b6_720w.jpg" alt="img"></p><h4 id="平板仰卧哑铃卧推（胸大肌中部）"><a href="#平板仰卧哑铃卧推（胸大肌中部）" class="headerlink" title="平板仰卧哑铃卧推（胸大肌中部）"></a>平板仰卧哑铃卧推（胸大肌中部）</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-3213c4484e6aea3e8e24c0a5080a30f8_720w.jpg" alt="img"></p><h4 id="下斜哑铃卧推（胸大肌下部）"><a href="#下斜哑铃卧推（胸大肌下部）" class="headerlink" title="下斜哑铃卧推（胸大肌下部）"></a>下斜哑铃卧推（胸大肌下部）</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-f7a4efe6e15aec101b7fe3c1f7363bef_720w.jpg" alt="img"></p><h3 id="杠铃卧推"><a href="#杠铃卧推" class="headerlink" title="杠铃卧推"></a>杠铃卧推</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-b1248247c80a35116a4016d5a5b981b8_720w.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-ef35e19a7fd979e30678d2c266895a21_b.webp" alt="img"></p><h4 id="杠铃窄距卧推（胸大肌内侧，肱三头肌）"><a href="#杠铃窄距卧推（胸大肌内侧，肱三头肌）" class="headerlink" title="杠铃窄距卧推（胸大肌内侧，肱三头肌）"></a>杠铃窄距卧推（胸大肌内侧，肱三头肌）</h4><p>对于大多数训练者来说，这个距离一定会小于你的肩膀宽度，窄距卧推的动作可以准确地刺激到肱三头肌和胸大肌内侧。窄握对于初学者来说有点困难，建议从小重量开始训练。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-cee3799c201d585fee49834a0d2d62f4_720w.jpg" alt="img"></p><h4 id="杠铃中距卧推（胸大肌中侧，肱三头肌）"><a href="#杠铃中距卧推（胸大肌中侧，肱三头肌）" class="headerlink" title="杠铃中距卧推（胸大肌中侧，肱三头肌）"></a>杠铃中距卧推（胸大肌中侧，肱三头肌）</h4><p>指杠铃杆下放到最接近胸部的位置时，小臂垂直于地面的卧推方式。这个握距在卧推训练中是最常见的，也是做起来最舒服的，能均匀地锻炼到胸部和上肢的肌群。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-a022b6f9cdfe28bc8d42b9323439eb8e_720w.jpg" alt="img"></p><h4 id="杠铃宽距卧推（胸大肌外侧，肱三头肌）"><a href="#杠铃宽距卧推（胸大肌外侧，肱三头肌）" class="headerlink" title="杠铃宽距卧推（胸大肌外侧，肱三头肌）"></a>杠铃宽距卧推（胸大肌外侧，肱三头肌）</h4><p>指杠铃杆下放到最接近胸部的位置时，大臂与小臂之间的夹角大于90度的卧推方式。这个握距可以训练到胸大肌外侧，同时也会给肩膀带来很大的刺激。需要注意的是，<strong>如果握距过宽，肩膀极容易受伤</strong>，<strong>在没有专业指导的情况下，不要盲目尝试。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-575279d352b9be5d6a12e245e5a14bc5_720w.jpg" alt="img"></p><h3 id="龙门架（胸大肌上、中、下）"><a href="#龙门架（胸大肌上、中、下）" class="headerlink" title="龙门架（胸大肌上、中、下）"></a>龙门架（胸大肌上、中、下）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/8bc53f2c-233d-11eb-8d54-427cd68ae3a7.gif" alt="8bc53f2c-233d-11eb-8d54-427cd68ae3a7"></p><p>​                                                                                            低位</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-a0189580b8d9ee9f5deaac6b4ecabe11_720w.gif" alt="img"></p><p>​                                                                                           高位</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-6a0637e4d587a41d6b82d256b59b7493_720w.gif" alt="img"></p><p>​                                                                                             平行</p><p>功能：绳索夹胸是一个孤立的胸肌的锻炼动作！涉及到的关节运动是肩内收，绳索夹胸也像卧推那样，不同角度不同刺激！其中就有高位，平行，低位的绳索夹胸。</p><p>使用方法</p><p>身体立于拉力器架中央，调节好拉索长度，挺胸！身体略前倾45度，弓步支撑，双手持环，微微屈肘，手臂向身前伸展，手掌相对。</p><p>注意事项</p><p>1.不要做过低次数的大重量拉伸，以免肩部受伤。每组10～15次。</p><p>2.整个动作过程中都要保持肘部的角度不变。</p><p>3.打开时注意控制动作，感受胸肌被拉伸，合拢时尽力挤压胸肌，略做停顿进行顶峰收缩。不要为了拉起更大的重量，身体前倾得厉害。此动作的要点是使胸部肌肉较充分拉伸与尽可能挤压，采用的重量是次要的</p><p>龙门架单独一侧使用时，可以使用配套的配件，小短杆，U型杆等，训练身体的其他部位，比如手臂，肩膀等。</p><h2 id="5、背部训练"><a href="#5、背部训练" class="headerlink" title="5、背部训练"></a>5、背部训练</h2><h3 id="高位下拉（背阔肌）"><a href="#高位下拉（背阔肌）" class="headerlink" title="高位下拉（背阔肌）"></a>高位下拉（背阔肌）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-4c0e6ce0cb1fc93c57b0b7a5f111c89f_720w.jpg" alt="img"></p><p><video class="ztext-gif GifPlayer-gif2mp4" src="https://vdn1.vzuu.com/SD/573d07a4-23c3-11eb-b73a-964718266243.mp4?disable_local_cache=1&amp;c=avc.0.0&amp;auth_key=1649567318-0-0-d029f49e4d06f96dfaaa6e280f1204a6&amp;f=mp4&amp;bu=pico&amp;expiration=1649567318&amp;v=hw" data-thumbnail="https://pica.zhimg.com/50/v2-ed7ddbd6a5daed71e0249c855d24c187_720w.jpg?source=1940ef5c" poster="https://pica.zhimg.com/50/v2-ed7ddbd6a5daed71e0249c855d24c187_720w.jpg?source=1940ef5c" data-size="normal" preload="metadata" loop="" playsinline="" __idm_id__="425986"></video><br> <em>使用方法：</em></p><p>1.坐在下拉训练器上，采用宽握正握握住把手。调整膝垫垫至合适位置。然后握稳横杠，身体微微后倾，肩膀微微外旋，稳定住身体！</p><p>2.启动肩胛，<a href="https://www.zhihu.com/search?q=%E8%83%8C%E9%98%94%E8%82%8C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:460377967%7D">背阔肌</a>发力收缩带动肱骨内收同时屈肘下拉！把把手拉到胸部锁骨上方，保持肘部靠近身体，停留两秒，挤压你的背阔肌，同时挺胸。</p><p>3.然后慢慢地伸展背阔肌，同时将手臂伸直尽量向上延伸（感觉背阔肌整个被拉伸）回到起始位置。注意整个过程中都保持背阔肌张力！</p><p><em>注意事项：</em></p><p>1.动作过程中请一定要充分延伸你的背阔肌（上放的时候把肩胛骨完全提起来，好像你要去摸一个很高物品）下拉时拉到最低端，努力挤压背部。</p><p>2.动作应该有序的进行，下放的时候要控制好节奏，不要自由落体，保持张力，慢慢伸展肌肉！</p><h3 id="坐姿划船（背阔肌，肱二头肌）"><a href="#坐姿划船（背阔肌，肱二头肌）" class="headerlink" title="坐姿划船（背阔肌，肱二头肌）"></a>坐姿划船（背阔肌，肱二头肌）</h3><p><a href="https://www.zhihu.com/zvideo/1386066565599834112">知乎视频链接</a></p><p>（拉到胸下部位置 上半身微微后仰）</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/4_170614163651_1.gif" alt="坐姿绳索划船- 坐姿器械划船动作图解教程_健身吧"></p><p>（拉到腹部位置 上半身不要后仰）</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-eb3d900303285006f6b40a915285d45e_b.gif" alt="练背的经典动作坐姿划船- 知乎"></p><p>（拉到腹部位置 上半身不要后仰 含胸）</p><p><em><strong>使用方法：</strong></em></p><p>胸椎保持挺直肩膀下沉，躯干保持稳定！双腿蹬实踏板，彷似要将踏板踩穿一样启动肩胛后收，双手顺势肘部往后拉、将把手拉向自己胸前，肩胛骨后收夹紧，挤压背肌两秒！然后慢慢回放重量，感觉你的背部打开拉伸，直到背肌完全伸展！</p><p>*<strong>注意事项：*</strong></p><p>动作过程中一定要注意维持躯干的稳定，切记不要弯背</p><h3 id="俯身单臂哑铃划船（背阔肌）"><a href="#俯身单臂哑铃划船（背阔肌）" class="headerlink" title="俯身单臂哑铃划船（背阔肌）"></a>俯身单臂哑铃划船（背阔肌）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-4a5908062cbc37246bce6c4ae14b71a2_720w.gif" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-13f8a84f85817a51cc321d4cc2e789ee_720w.jpg" alt="img"></p><h2 id="6、肩部训练"><a href="#6、肩部训练" class="headerlink" title="6、肩部训练"></a>6、肩部训练</h2><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-14427270827b64097a045cc76cd769c3_720w.jpg" alt="img"></p><h3 id="坐姿器械推肩（三角肌，肱三头肌）"><a href="#坐姿器械推肩（三角肌，肱三头肌）" class="headerlink" title="坐姿器械推肩（三角肌，肱三头肌）"></a>坐姿器械推肩（三角肌，肱三头肌）</h3><p>1.坐在训练凳上，调整好座椅高度，背部稳稳靠在凳子上。身体保持胸、收腹、沉肩、下颚微微内收的姿态。双　</p><p>2.选择合适的重量。手握把手，肘关节90度，手腕直立。　</p><p>3.肩部三角肌发力向上推起把手（肘关节微屈，双臂不要完全伸直），充分感觉三角肌的收缩。　　</p><p>4.完成动作后，慢慢下放至大臂和地面平行或略低，不要使器械的配重片相撞　　上推时呼气，放时吸气。　　</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-eed24be471225cbd1445e8ff62e689a3_b.webp" alt="img"></p><h3 id="哑铃推肩"><a href="#哑铃推肩" class="headerlink" title="哑铃推肩"></a>哑铃推肩</h3><h4 id="坐姿哑铃推肩（三角肌前束）"><a href="#坐姿哑铃推肩（三角肌前束）" class="headerlink" title="坐姿哑铃推肩（三角肌前束）"></a>坐姿哑铃推肩（三角肌前束）</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/tuijian1.gif" alt="tuijian1"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/tuijian2.gif" alt="tuijian2"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-dca01fd70be94b78d618192ec9f2cf95_720w.jpg" alt="img"></p><h4 id="站姿哑铃侧平举（三角肌中束）"><a href="#站姿哑铃侧平举（三角肌中束）" class="headerlink" title="站姿哑铃侧平举（三角肌中束）"></a>站姿哑铃侧平举（三角肌中束）</h4><p>肩部外旋</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/ab5f0957652945f48a99abf0f3cf35ec_640x0.gif" alt="想要练出宽肩，对哑铃侧平举做出4步调整，"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/1331012018-5.jpg" alt="正确进行哑铃侧平举是宽肩的关键_小改变"></p><h4 id="俯身哑铃侧平举（三角肌中、后束）"><a href="#俯身哑铃侧平举（三角肌中、后束）" class="headerlink" title="俯身哑铃侧平举（三角肌中、后束）"></a>俯身哑铃侧平举（三角肌中、后束）</h4><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/download.gif" alt="看了这组虐肩动作，你就知道自己和大神差在哪儿了！_手机网易网"></p><h2 id="7、手臂训练"><a href="#7、手臂训练" class="headerlink" title="7、手臂训练"></a>7、手臂训练</h2><h3 id="坐姿哑铃交替弯举（肱二头肌）"><a href="#坐姿哑铃交替弯举（肱二头肌）" class="headerlink" title="坐姿哑铃交替弯举（肱二头肌）"></a>坐姿哑铃交替弯举（肱二头肌）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-eedf5ba26e42d30c2f09a6eca4eb68b8_720w.jpg" alt="img"></p><h3 id="坐姿哑铃颈后臂屈伸（肱三头肌）"><a href="#坐姿哑铃颈后臂屈伸（肱三头肌）" class="headerlink" title="坐姿哑铃颈后臂屈伸（肱三头肌）"></a>坐姿哑铃颈后臂屈伸（肱三头肌）</h3><h2 id="8、腿部训练"><a href="#8、腿部训练" class="headerlink" title="8、腿部训练"></a>8、腿部训练</h2><h3 id="腿弯举（股二头肌，大腿后侧）"><a href="#腿弯举（股二头肌，大腿后侧）" class="headerlink" title="腿弯举（股二头肌，大腿后侧）"></a>腿弯举（股二头肌，大腿后侧）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-249cc01399db1390e636a75eaff9b473_720w.jpg" alt="img"></p><p>*<strong>使用方法：*</strong></p><p>1.初始动作：俯卧在一个腿弯举器上，你的膝盖正好刚刚超过俯卧板的末端。调整阻力滚垫以使你的脚踝后面正好卡在滚垫下。抓住手柄并深吸气。</p><p>2.动作过程：保持你的躯干平直，收缩你的股二头肌来使滚垫朝你的臀部运动，当动作到达中点时，开始呼气。在动作的顶端，努力挤压你的股二头肌，然后慢慢反向返回至初始位置。</p><p>*<strong>注意事项：*</strong></p><ol><li>勾起重量时小腿不宜超过垂直面，还原时股二头肌要用力控制，两腿不完全伸直，保持张紧状态，动作过程不能靠惯性。如出现这一情形说明负重过轻，应适当增加试举重量，并注意控制动作节奏，如向心收缩稍快，离心收缩稍慢。</li><li>股二头肌收缩用力时臀部不可抬起.避免借力。如出现这一情形说明负重过重，应减轻试举重量，意念集中在主动肌的收缩和伸展上。</li></ol><p>腿屈伸（股四头肌，大腿前侧）</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-81da2980b7521ee0af67f19d5c72abca_720w.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-895d86405ac86d4ccf4b585b981b2894_720w.jpg" alt="img"></p><p>*<strong>使用方法：*</strong></p><p>1.坐在腿屈伸机上，腰背靠紧靠板，两手握扶把，两腿屈膝下垂，双脚勾住横杠。</p><p>2.股四头肌收缩用力伸小腿举起重量,在最高点时充分收缩股四头肌，稍停。然后慢慢下放重量，至最低点前接着做下次动作。</p><p>*<strong>注意事项：*</strong></p><p>1.股四头肌用力收缩时<a href="https://link.zhihu.com/?target=http://www.jianshen8.com/zhuanti/beibu.html">背部</a>不能离开靠板，<a href="https://link.zhihu.com/?target=http://www.jianshen8.com/zhuanti/tundaji.html">臀大肌</a>不宜抬起借力，否则会使主动肌受力减少，锻炼效果欠佳。因此练习负荷要适当，动作要领标准为前提。 </p><p>2.动作过程始终勾起脚尖，如果没有勾起脚尖，股四头肌得不到彻底收缩。</p><h3 id="哑铃负重深蹲（股四头肌，大腿前侧）（臀大肌）"><a href="#哑铃负重深蹲（股四头肌，大腿前侧）（臀大肌）" class="headerlink" title="哑铃负重深蹲（股四头肌，大腿前侧）（臀大肌）"></a>哑铃负重深蹲（股四头肌，大腿前侧）（臀大肌）</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-d1e52d09f19b07ac994a99c5dca6451f_720w.png" alt="img"></p><h2 id="9、腹部训练"><a href="#9、腹部训练" class="headerlink" title="9、腹部训练"></a>9、腹部训练</h2><h3 id="跪姿绳索卷腹"><a href="#跪姿绳索卷腹" class="headerlink" title="跪姿绳索卷腹"></a>跪姿绳索卷腹</h3><p><strong>不要用手臂力量拉动绳索，要用腹部。</strong></p><p>这是健身房里较为常见的动作，都是卷腹动作，<strong>通过绳索和负重可以增大肌肉的负荷</strong>，让有一定训练基础的健身者获得更好的健腹效果。</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-ad4c6cdebd8bb83acdc07d7f8b056ae8_b.webp" alt="img"></p><p>髋关节</p><p>​    动作要求把<strong>髋关节锁定</strong>，<strong>避免在过程中进行前后移动</strong>，用身体重量拉下绳索，如果你的屁股坐在小腿上，降低腹直肌收缩效率，锁定髋关节最简单的方法就是抬高屁股，大腿尽量垂直地面，仅弯曲脊柱收缩腹肌即可。</p><p>双手位置</p><p>​    双手抓我绳索的位置决定了力臂杠杆的距离，力臂越长，作用力越大，对腹肌的收缩刺激效果越好，所以<strong>双手抓我绳索放置在额头处效果会好</strong>，<strong>把下巴缩回到胸口位置保持</strong>，这样可以让手臂保持收紧固定，延长杠杆长度，即使在小重量练习时依旧可以获得不错的刺激感。****</p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-9f79ea63b7044bd3ac0f6094d59a3266_720w.jpg" alt="img"></p><p><a href="https://www.bilibili.com/video/BV1Tg411T7LD?spm_id_from=333.337.search-card.all.click">其他健身房练习腹肌见BiliBili</a></p><h3 id="腹肌练习动作"><a href="#腹肌练习动作" class="headerlink" title="腹肌练习动作"></a>腹肌练习动作</h3><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-948bc8d5c1cf97fbcef7a9af685e4272_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-42cb5547570498a127b3af5546f03898_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/13b5d478-2361-11eb-bdf0-f60054b0d559.gif" alt="13b5d478-2361-11eb-bdf0-f60054b0d559"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-78e986e7a30f53809cf3a8a73c8e60cc_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/f42f3dd2-2370-11eb-87bf-56a86397507f.gif" alt="f42f3dd2-2370-11eb-87bf-56a86397507f"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-300736eec8bb80aa9c1d69956436ca5a_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-ba3e9c9a07989b43e138be7bdc34d9ca_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-9a492cf4d6dd0e50bfbf086a7e4b3f5f_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/v2-4533402864401633ef98d866e3406ef3_b.webp" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/XuxuGood/simple-blog-cdn@master/images/site-img/loading3.gif" data-original="https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo/438db348-23aa-11eb-a8e0-0257ce2c6f9c.gif" alt="438db348-23aa-11eb-a8e0-0257ce2c6f9c"></p>]]></content>
      
      
      <categories>
          
          <category> 学习之余 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健身 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL学习笔记</title>
      <link href="/2022/05/12/c-stl-xue-xi-bi-ji/"/>
      <url>/2022/05/12/c-stl-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="一、C-STL-API"><a href="#一、C-STL-API" class="headerlink" title="一、C++STL API"></a>一、C++STL API</h1><h2 id="1、算法常用模板"><a href="#1、算法常用模板" class="headerlink" title="1、算法常用模板"></a>1、算法常用模板</h2><pre><code class="hljs c++">include&lt;bits/stdc++.h&gt; <span class="hljs-comment">//万能头 C++版本4.4以上支持</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-comment">//pass</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><h2 id="2、algorithm-标准算法库"><a href="#2、algorithm-标准算法库" class="headerlink" title="2、algorithm//标准算法库"></a>2、algorithm//标准算法库</h2><pre><code class="hljs cpp"><span class="hljs-built_in">min</span>(x, y); <span class="hljs-built_in">max</span>(x, y);<span class="hljs-built_in">abs</span>(x); <span class="hljs-comment">//求绝对值</span><span class="hljs-built_in">swap</span>(x, y); <span class="hljs-comment">//交换x和y的值</span><span class="hljs-built_in">reverse</span>(it2, it2); <span class="hljs-comment">//将数组指针或容器迭代器在[it1,it2)范围内的元素进行翻转</span><span class="hljs-built_in">next_permutation</span>(); <span class="hljs-comment">//给出序列在全排列中的下一个序列</span><span class="hljs-built_in">fill</span>(a,b,<span class="hljs-number">1</span>); <span class="hljs-comment">//对数组或容器中某段区间赋值为某个相同的值，样例区间为[a,b)赋值为1</span><span class="hljs-built_in">sort</span>(首地址, 尾元素下一个地址, 比较函数(optional)); <span class="hljs-comment">//比较函数为空时默认递增排序</span><span class="hljs-comment">//实现比较函数的tip: 当cmp(a,b)为true时a放在b之前</span><span class="hljs-comment">//STL标准容器中，vector, string, deque支持sort，内部本身有序的那种不支持排序</span><span class="hljs-built_in">lower_bound</span>(first, last, val); <span class="hljs-comment">//查找数组或容器的[first, last)范围内第一个值大于等于val元素的位置，返回数组指针或容器该位置的迭代器</span><span class="hljs-built_in">upper_bound</span>(first, last, val);<span class="hljs-comment">//查找数组或容器的[first, last)范围内第一个值大于val元素的位置，返回数组指针或容器该位置的迭代器</span></code></pre><h2 id="3、queue-队列"><a href="#3、queue-队列" class="headerlink" title="3、queue//队列"></a>3、queue//队列</h2><h3 id="1-queue"><a href="#1-queue" class="headerlink" title="(1)queue"></a>(1)queue</h3><p>实现先进先出（FIFO）的容器，常用于BFS实现；类似的还有双端队列（deque），首尾均可插入和删除；</p><ol><li>定义</li></ol><pre><code class="hljs cpp">queue&lt;<span class="hljs-keyword">typename</span>&gt; instName;</code></pre><ol start="2"><li>访问</li></ol><pre><code class="hljs cpp"><span class="hljs-built_in">front</span>(); <span class="hljs-comment">//访问队首元素</span><span class="hljs-built_in">back</span>(); <span class="hljs-comment">//访问队尾元素</span></code></pre><ol start="3"><li>常用函数</li></ol><pre><code class="hljs cpp"><span class="hljs-built_in">push</span>(); <span class="hljs-comment">//入队，复杂度O(1)</span><span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//出队，复杂度O(1)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空，复杂度O(1)</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取元素个数，复杂度O(1)</span></code></pre><ol start="4"><li>常用函数</li></ol><pre><code class="hljs cpp"><span class="hljs-built_in">push_back</span>(); <span class="hljs-built_in">push_front</span>(); <span class="hljs-comment">//队尾||首入队，复杂度O(1)</span><span class="hljs-built_in">pop_back</span>(); <span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">//队尾||首出队，复杂度O(1)</span><span class="hljs-built_in">front</span>(); <span class="hljs-built_in">back</span>(); <span class="hljs-comment">//访问队首、队尾</span><span class="hljs-keyword">operator</span>[] (size_type n); <span class="hljs-comment">//访问，复杂度O(1)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空，复杂度O(1)</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取元素个数，复杂度O(1)</span></code></pre><h3 id="2-priority-queue-二叉堆"><a href="#2-priority-queue-二叉堆" class="headerlink" title="(2)priority_queue//二叉堆"></a>(2)priority_queue//二叉堆</h3><p>常用：求数组第k个值，</p><p>1、二叉堆：</p><p>大顶堆：less<typename>或自定义用＜操作符￼<br>小于号&lt;规定了优先级，表示优先队列后面的元素都要小于优先队列前面的元素，因为优先队列队首的元素优先级最高，优先队列队尾元素的优先级最低，所以小于号&lt;就规定了优先队列后面的元素都要小于优先队列前面的元素（尾部优先级小于首部优先级），也就是形成一个大根堆，降序排序，每次权值最大的会被弹出来。</typename></p><p>小顶堆：greater<typename>或自定义用＞操作符<br>这里的大于号&gt;规定了优先级，表示优先队列后面的元素都要大于优先队列前面的元素，因为优先队列队首的元素优先级最高，优先队列队尾元素的优先级最低，所以大于号&gt;就规定了优先队列后面的元素都要大于优先队列前面的元素（尾部优先级小于首部优先级），也就是形成一个小根堆，升序排序，每次权值最小的会被弹出来。</typename></p><p><strong>每当插入一个数后，优先队列会根据优先级自动调整好结构。</strong></p><p>2、默认是以数字大为优先级</p><p>3、可设置优先级</p><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-keyword">typename</span>, vector&lt;<span class="hljs-keyword">typename</span>&gt;, cmp_fn&gt; instName;cmp_fn 可使用 le￼ss&lt;<span class="hljs-keyword">typename</span>&gt;: 设置大顶堆，以及greater&lt;<span class="hljs-keyword">typename</span>&gt;: 设置小顶堆<span class="hljs-built_in">push</span>(); <span class="hljs-comment">//push(x)，将x入队，复杂度O(logN)</span><span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//队首元素出队，复杂度O(logN)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空，复杂度O(1)</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//返回元素个数，复杂度O(1)</span><span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回顶部元素</span></code></pre><p>4、自定义队列的比较方式</p><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myComparison</span>{<span class="hljs-comment">//创建结构体</span>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;p1,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp;p2)</span></span>{           <span class="hljs-keyword">return</span> p1.second&gt;p2.second;<span class="hljs-comment">//小顶堆是大于号</span>        }     };<span class="hljs-comment">//创建优先队列</span>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,myComparison&gt; q;<span class="hljs-comment">//最后一个参数放入结构体</span></code></pre><h2 id="4、stack-栈"><a href="#4、stack-栈" class="headerlink" title="4、stack//栈"></a>4、stack//栈</h2><p>后进先出的容器，</p><ol><li>基本定义方式：</li></ol><pre><code class="hljs cpp">stack&lt;<span class="hljs-keyword">typename</span>&gt; instName;</code></pre><p>​    2.常用函数</p><pre><code class="hljs cpp"><span class="hljs-built_in">push</span>(); <span class="hljs-comment">//元素入栈，复杂度O(1)</span><span class="hljs-built_in">top</span>(); <span class="hljs-comment">//获得栈顶元素，复杂度O(1)</span><span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出栈顶元素，复杂度O(1)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空，复杂度O(1)</span></code></pre><h2 id="5、utility"><a href="#5、utility" class="headerlink" title="5、utility"></a>5、utility</h2><p>常用于将两个元素捆绑成为合成元素，以及用于构造map的键值对；</p><ol><li>定义</li></ol><pre><code class="hljs cpp">pair&lt;typename1, typename2&gt; instName;<span class="hljs-comment">//example1: </span><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">"example"</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">//example2: </span><span class="hljs-built_in">make_pair</span>(<span class="hljs-string">"example"</span>,<span class="hljs-number">0</span>);</code></pre><ol start="2"><li>常用函数</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//比较操作数&lt;=、&gt;=等，pair可以直接比较，默认先以first大小作为标准，当fisrt相等时使用second;</span></code></pre><h2 id="6、vector-数组"><a href="#6、vector-数组" class="headerlink" title="6、vector//数组"></a>6、vector//数组</h2><p>相当于Java的ArrayList数据结构，可加入泛型。</p><p>URL :<a href="https://zhuanlan.zhihu.com/p/150118797">https://zhuanlan.zhihu.com/p/150118797</a></p><p>1、初始化</p><pre><code class="hljs cpp">一维使用：vector&lt;type&gt; name直接赋值（C++<span class="hljs-number">11</span>支持）：vector&lt;<span class="hljs-type">int</span>&gt; name = {<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>};<span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>};<span class="hljs-comment">//返回数组</span>直接赋值：利用数组，初始化成vector容器<span class="hljs-type">int</span> i[<span class="hljs-number">2</span>] = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>};<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ii</span><span class="hljs-params">(i,i+<span class="hljs-number">2</span>)</span></span>;一维使用并且开空间赋初值：<span class="hljs-function">vctor&lt;type&gt; <span class="hljs-title">name</span><span class="hljs-params">(size,initValue)</span></span><span class="hljs-function"></span><span class="hljs-function">二维使用：vector&lt;vector&lt;type&gt;&gt; name</span><span class="hljs-function"></span><span class="hljs-function">初始化开空间：vector.<span class="hljs-title">resize</span><span class="hljs-params">(capacity)</span></span><span class="hljs-function"></span><span class="hljs-function">对于二维数组：</span><span class="hljs-function"></span><span class="hljs-function">​    vector.<span class="hljs-title">resize</span><span class="hljs-params">(capacity)</span> <span class="hljs-comment">//初始化一维空间</span></span><span class="hljs-function"></span><span class="hljs-function">​    <span class="hljs-title">for</span><span class="hljs-params">(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt;n;i++)</span></span>{<span class="hljs-comment">//初始化二维空间</span>​      order[i].<span class="hljs-built_in">resize</span>(capacity);​    }</code></pre><p>2、函数方法</p><pre><code class="hljs cpp">长度：vector.<span class="hljs-built_in">size</span>()<span class="hljs-built_in">begin</span>(); <span class="hljs-built_in">end</span>(); <span class="hljs-built_in">rbegin</span>(); <span class="hljs-built_in">rend</span>(); <span class="hljs-comment">//返回迭代器，r为reversed的缩写</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空</span><span class="hljs-built_in">front</span>(); <span class="hljs-built_in">back</span>(); <span class="hljs-comment">//返回vector的首/尾值</span><span class="hljs-built_in">push_back</span>(); <span class="hljs-comment">//尾部添加元素，复杂度O(1)</span><span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">//尾部删除元素，复杂度O(1)</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取元素个数</span><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空所有元素，复杂度O(N)</span><span class="hljs-built_in">insert</span>(it,value); <span class="hljs-comment">//向任意迭代器it处插入一个元素value, 复杂度O(N)，功能同emplace()</span><span class="hljs-built_in">erase</span>(); <span class="hljs-comment">//可删除单个元素:erase(it)，或删除区间[first, larst)内所有元素:erase(first_it, last_it)</span><span class="hljs-built_in">swap</span>(vector&amp; x); <span class="hljs-comment">//与另外一个vector container交换数据</span></code></pre><p>3、排序</p><p>自定义排序（顺序）：</p><pre><code class="hljs cpp"><span class="hljs-number">1</span>、直接使用lambda表达式自定义按照二维数组<span class="hljs-built_in">sort</span>(courses.<span class="hljs-built_in">begin</span>(),courses.<span class="hljs-built_in">end</span>(),[](vector&lt;<span class="hljs-type">int</span>&gt;&amp; o1,vector&lt;<span class="hljs-type">int</span>&gt;&amp; o2){<span class="hljs-comment">//lambda表达式</span>      <span class="hljs-keyword">return</span> o1[<span class="hljs-number">1</span>] &gt; o2[<span class="hljs-number">1</span>];<span class="hljs-comment">//根据vector[][1]降序排序，大于号 表示数组前面的元素要大于后面的元素。</span>  });<span class="hljs-number">2</span>、自定义函数（降序排序）<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{    <span class="hljs-keyword">return</span> x &gt; y;}<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{    <span class="hljs-type">int</span> a[] = {<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>};    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr</span><span class="hljs-params">(a, a+<span class="hljs-number">5</span>)</span></span>;    <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>(),cmp_max);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;arr.<span class="hljs-built_in">size</span>(); ++i){        cout &lt;&lt;arr[i] &lt;&lt; <span class="hljs-string">" "</span>;    }    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;}output：<span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><span class="hljs-number">3</span>、vector局部排序<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>{    <span class="hljs-keyword">return</span> x &gt; y;}vector&lt;<span class="hljs-type">int</span>&gt; array = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};<span class="hljs-built_in">sort</span>(array.<span class="hljs-built_in">begin</span>(),array.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>,cmp);<span class="hljs-comment">//对[0,3)下标之间进行逆序排序</span>output:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>    <span class="hljs-built_in">sort</span>(array.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>,array.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">5</span>,cmp);<span class="hljs-comment">//对[1,5)下标之间进行逆序排序</span>output:<span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span>    <span class="hljs-built_in">sort</span>(array.<span class="hljs-built_in">begin</span>(),array.<span class="hljs-built_in">end</span>()<span class="hljs-number">-2</span>,cmp);<span class="hljs-comment">//对[0,2)下标之间进行逆序排序</span>output:<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre><h2 id="7、string-字符串"><a href="#7、string-字符串" class="headerlink" title="7、string//字符串"></a>7、string//字符串</h2><ol><li>定义：</li></ol><pre><code class="hljs cpp">string str;string str = <span class="hljs-string">"example string"</span>;</code></pre><ol start="2"><li><p>访问：可通过下标或迭代器，与vector基本类似</p></li><li><p>常用函数：</p></li></ol><pre><code class="hljs cpp"><span class="hljs-built_in">append</span>()：从后方插入字符串直接字符串相加：    string a = <span class="hljs-string">"hello"</span>;    string b = <span class="hljs-string">"hello"</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i)    {        a = b + a;    }<span class="hljs-comment">//operator+=, 用于字符串拼接</span><span class="hljs-comment">//compare operator: ==、!=、&lt;=、&gt;=等，基于字典序比较大小</span><span class="hljs-built_in">length</span>()/<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//返回string长度</span><span class="hljs-built_in">insert</span>(); <span class="hljs-comment">//插入字符串，复杂度O(N)</span><span class="hljs-comment">//insert(pos, string)--&gt;在pos未知插入字符串string</span><span class="hljs-comment">//insert(it, it2, it3)--&gt;迭代器指示的string it位置上插入串[it2,it3]</span><span class="hljs-built_in">erase</span>(); <span class="hljs-comment">//删除单个或区间内元素，与vector中erase用法基本一致，复杂度O(N)</span><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空，复杂度O(1)</span><span class="hljs-built_in">substr</span>(); <span class="hljs-comment">//substr(pos, len)返回pos位置开始长度为len的字串，复杂度O(len)</span><span class="hljs-built_in">find</span>(); <span class="hljs-comment">//str.find(str2), 当str2是str的字串时，返回其在str中第一次出现的位置，否则返回string:npos</span><span class="hljs-comment">//str.dinf(pos, str2), 从str的pos位置开始匹配, 复杂度O(mn), m、n为str和str2的长度</span>string:npos; <span class="hljs-comment">//常数(=-1, or 4294967295, max value of unsigned_int)，一般作为find函数失配时的返回值</span><span class="hljs-built_in">replace</span>(); <span class="hljs-comment">//replace(pos, len, str2), 把str从pos号位开始长度为len的字串替换为str2; </span><span class="hljs-comment">//replace(it1, it2, str2), 把str的迭代器[it1, it2)范围的字串替换为str2; 复杂度为O(str.length())</span><span class="hljs-number">1</span>、string与<span class="hljs-type">int</span>互转(C++<span class="hljs-number">11</span>不支持)<span class="hljs-built_in">stoi</span>(str, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//将字符串 str 从 0 位置开始到末尾的 2 位置转换为十进制</span><span class="hljs-built_in">stoi</span>(str);<span class="hljs-comment">//将“字符串”转为十进制</span><span class="hljs-built_in">stod</span>()<span class="hljs-comment">//“字符串”转换为double</span><span class="hljs-built_in">to_string</span>(<span class="hljs-type">char</span> c)<span class="hljs-comment">//重载方法，将一些整形，浮点型等转换为string类型字符串</span><span class="hljs-number">2</span>、string与<span class="hljs-type">int</span>互转<span class="hljs-comment">// int 转 string</span>  <span class="hljs-type">int</span> number = <span class="hljs-number">12</span>;  string str;  stringstream ss;  ss&lt;&lt;number;  ss&gt;&gt;str;  cout&lt;&lt;str; <span class="hljs-comment">//注意，此时这个流中还留有之前流入的数据。</span> ss.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">//清楚这个流中残留的数据</span> <span class="hljs-comment">//string 转 int</span>  string str2 = <span class="hljs-string">"13"</span>;  <span class="hljs-type">int</span> num;  ss&lt;&lt;str2;  ss&gt;&gt;num;  cout&lt;&lt;num;<span class="hljs-number">2</span>、<span class="hljs-type">char</span>与<span class="hljs-type">int</span>互转，string[index]是<span class="hljs-type">char</span>类型<span class="hljs-string">'1'</span>-<span class="hljs-string">'0'</span>(输出<span class="hljs-type">int</span>类型的<span class="hljs-number">1</span>)：<span class="hljs-type">char</span>转<span class="hljs-type">int</span>，使用ASCII码方法<span class="hljs-type">int</span>转<span class="hljs-type">char</span>：    <span class="hljs-type">char</span> z1 = <span class="hljs-number">1</span> +<span class="hljs-string">'0'</span>;    cout&lt;&lt;z1&lt;&lt;endl;<span class="hljs-comment">//'1'</span>    cout&lt;&lt;<span class="hljs-built_in">char</span>(<span class="hljs-number">1</span> +<span class="hljs-string">'0'</span>)&lt;&lt;endl;<span class="hljs-comment">//'1'</span>    cout&lt;&lt; <span class="hljs-number">1</span> +<span class="hljs-string">'0'</span>&lt;&lt;endl;<span class="hljs-comment">//'49'，此处输出的是1的ASCII值，而不是字符</span></code></pre><h2 id="8、map-映射"><a href="#8、map-映射" class="headerlink" title="8、map//映射"></a>8、map//映射</h2><p>映射，可以将任何基本类型映射到任何基本类型（包含STL容器）；内部由红黑树实现，因此建立映射过程中自动有序（从小到大）；若需要一个key对应多个值，可以使用multimap；C++11中增加了散列实现的unordered_map，速度比红黑树实现的map要快很多.</p><p>常用用途为：</p><ol><li><p>需要建立字符串与整数/字符串间的映射；</p></li><li><p>判断大整数或其他类型数据是否存在时，把map当bool数组使用；</p></li></ol><ol><li>定义</li></ol><pre><code class="hljs cpp">map&lt;typename1, typename2&gt; instName;</code></pre><ol start="2"><li>访问：通过下标或迭代器</li></ol><p>通过迭代器访问时，it-&gt;first用来访问key, it-&gt;second用来访问value</p><ol start="3"><li>常用函数</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//[]复杂度O(logN)，等价于(*((this-&gt;insert(make_pair(k,mapped_type()))).first)).second</span><span class="hljs-keyword">operator</span>[] (<span class="hljs-type">const</span> key_type&amp; k); <span class="hljs-comment">//当key k存在时返回value的reference，否则构造新的k-v对，并初始化v</span><span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> value_type&amp; val); <span class="hljs-comment">//插入新k-v pair，一般需要通过std::pair构造，如: std::pair&lt;char,int&gt;('a',100)</span><span class="hljs-built_in">find</span>(<span class="hljs-type">const</span> key_type&amp; k); <span class="hljs-comment">//find(key)返回键为key的映射迭代器，时间复杂度O(logN)</span><span class="hljs-built_in">count</span>(<span class="hljs-type">const</span> key_type&amp; k); <span class="hljs-comment">//只能为1或者0，功能等价于find();</span><span class="hljs-built_in">erase</span>(); <span class="hljs-comment">//可删除单个元素:erase(it)，复杂度O(1);erase(key),删除键为key的键值对，复杂度O(logN)</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取元素个数，复杂度O(1)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空</span><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空元素，复杂度O(N)</span><span class="hljs-built_in">lower_bound</span> (<span class="hljs-type">const</span> value_type&amp; val); <span class="hljs-comment">//参考https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo头文件下常用函数</span></code></pre><h2 id="9、set-集合"><a href="#9、set-集合" class="headerlink" title="9、set//集合"></a>9、set//集合</h2><p>set，集合，为内部自动有序(note: 增序)且不含重复元素的容器，内部由红黑树实现。相似的容器为multiset，内部可以允许有重复元素；unordered_set，可以去重但是无序，内部由散列实现，速度比set要快很多。</p><ol><li>定义：</li></ol><pre><code class="hljs cpp">set&lt;<span class="hljs-keyword">typename</span>&gt; instName;</code></pre><ol start="2"><li>访问：一般通过迭代器访问</li></ol><pre><code class="hljs cpp">set&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it; <span class="hljs-comment">//通过*it访问set的元素，但注意只能使用for-loop枚举，不支持*(it+i)的方式访问</span><span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> 只有vector和string支持*(it+i)的访问方式</span></code></pre><ol start="3"><li>常用函数：</li></ol><pre><code class="hljs cpp"><span class="hljs-built_in">begin</span>(); <span class="hljs-built_in">end</span>(); <span class="hljs-built_in">rbegin</span>(); <span class="hljs-built_in">rend</span>(); <span class="hljs-comment">//返回迭代器，r为reversed的缩写</span><span class="hljs-comment">// Capacity</span><span class="hljs-built_in">size</span>(); <span class="hljs-comment">//获取set内元素个数，复杂度O(1)</span><span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判空</span><span class="hljs-comment">// Modifiers</span><span class="hljs-built_in">insert</span>(); <span class="hljs-comment">//insert(x)将x插入容器中，时间复杂度O(logN)</span><span class="hljs-built_in">erase</span>(); <span class="hljs-comment">//可删除单个元素:erase(it)，复杂度O(1);或删除区间[first, larst)内所有元素:erase(first_it, last_it),复杂度O(logN)</span><span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空set中所有元素，复杂度O(N)</span><span class="hljs-comment">// Operations</span><span class="hljs-built_in">find</span>(); <span class="hljs-comment">//返回set中对应值为value的迭代器，时间复杂度O(logN)</span><span class="hljs-built_in">count</span>(); <span class="hljs-comment">//Count elements with a specific value</span><span class="hljs-built_in">lower_bound</span> (<span class="hljs-type">const</span> value_type&amp; val); <span class="hljs-comment">//参考https://gendml.oss-cn-hangzhou.aliyuncs.com/picgo头文件下常用函数</span></code></pre><h2 id="10、cmath-数学函数库"><a href="#10、cmath-数学函数库" class="headerlink" title="10、cmath//数学函数库"></a>10、cmath//数学函数库</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> 求n的绝对值</span><span class="hljs-function"><span class="hljs-type">double</span> cos/sin/<span class="hljs-title">tan</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> 求x的三角函数值（x为弧度值）</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">exp</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> 求e的x次方</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x,<span class="hljs-type">double</span> y)</span> 求x的y次方</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> 求x的平方根</span><span class="hljs-function">    </span></code></pre><h2 id="11、cstdio-IO（C）"><a href="#11、cstdio-IO（C）" class="headerlink" title="11、cstdio//IO（C）"></a>11、cstdio//IO（C）</h2><pre><code class="hljs cpp"><span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;a);<span class="hljs-comment">//格式化输入</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%.2f\n"</span>, b);<span class="hljs-comment">//格式化输出</span></code></pre><h2 id="12、cstdlib-工具库（C）"><a href="#12、cstdlib-工具库（C）" class="headerlink" title="12、cstdlib//工具库（C）"></a>12、cstdlib//工具库（C）</h2><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><span class="hljs-comment">    C语言中的字符串为char *temp</span><span class="hljs-comment">    C++为string</span><span class="hljs-comment">*/</span><span class="hljs-built_in">atoi</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)<span class="hljs-comment">//将一串“字符”转换为int型（注意参数类型是const char*）</span><span class="hljs-built_in">atof</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)<span class="hljs-comment">//同上，转换为double型（注意参数类型是const char*）</span>string1.<span class="hljs-built_in">c_str</span>()：string转<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>*</span><span class="hljs-function"><span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//取绝对值</span></span><span class="hljs-function"><span class="hljs-title">fill</span><span class="hljs-params">()</span><span class="hljs-comment">//区域赋值</span></span><span class="hljs-function"><span class="hljs-comment">/*    int a[10];</span></span><span class="hljs-comment"><span class="hljs-function">      vector&lt;int&gt; vt;</span></span><span class="hljs-comment"><span class="hljs-function">      fill(a, a+10, 100000);</span></span><span class="hljs-comment"><span class="hljs-function">      fill(vt.begin(), vt.end(), -100000);</span></span><span class="hljs-comment"><span class="hljs-function">*/</span></span><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">(vt.begin(), vt.end(), cmp)</span></span>;<span class="hljs-comment">//时间复杂度n*log(n)的排序算法，默认升序</span><span class="hljs-built_in">max</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<span class="hljs-comment">//取最大值</span><span class="hljs-built_in">min</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<span class="hljs-comment">//取最小值</span><span class="hljs-built_in">strcmp</span>(<span class="hljs-type">char</span>* str1, <span class="hljs-type">char</span>* str2)<span class="hljs-comment">//比较两个字符串，前一个小返回&lt;0，前一个大返回&gt;0，否则返回0</span><span class="hljs-built_in">strcpy</span>(<span class="hljs-type">char</span>* destination, <span class="hljs-type">char</span>* source)<span class="hljs-comment">//将后一个字符串拷贝到前一个字符串</span><span class="hljs-built_in">strlen</span>(<span class="hljs-type">char</span>* str)<span class="hljs-comment">//返回字符串str的有效长度</span><span class="hljs-built_in">isalnum</span>()<span class="hljs-comment">//判断一个字符是不是alphanumeric，即大小写英文字母或是数字</span><span class="hljs-built_in">isalpha</span>()<span class="hljs-comment">//判断一个字符是不是alphabetic，即英文字母</span><span class="hljs-built_in">isdigit</span>()<span class="hljs-comment">//判断一个字符是不是数字</span><span class="hljs-built_in">tolower</span>()<span class="hljs-comment">//将大写转换为小写</span><span class="hljs-built_in">toupper</span>()<span class="hljs-comment">//将小写转换为大写</span></code></pre><h2 id="13、cstring（C）"><a href="#13、cstring（C）" class="headerlink" title="13、cstring（C）"></a>13、cstring（C）</h2><p>c语言的字符串库</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
